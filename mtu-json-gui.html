<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTU ç»ˆæç‰ˆ (v3.6 æ€§èƒ½å¼€å…³ç‰ˆ)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', 'Noto Sans SC', sans-serif; background-color: #111827; color: #e5e7eb; height: 100vh; overflow: hidden; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        
        .sidebar-item { 
            transition: all 0.1s; 
            border: 2px solid transparent; 
            margin-bottom: 4px;
        }
        .sidebar-item:hover { background-color: #374151; }
        .sidebar-item.active { 
            background-color: #1f2937; 
            border: 2px solid #ef4444; 
            box-shadow: inset 0 0 15px rgba(239, 68, 68, 0.15); 
        }
        
        #canvasContainer { 
            display: flex; 
            background-image: radial-gradient(#374151 1px, transparent 1px); 
            background-size: 20px 20px; 
            overflow: hidden; /* <--- ä¿®æ”¹è¿™é‡Œï¼šå»æ‰ autoï¼Œæ”¹ä¸º hidden */
            position: relative;
            cursor: grab; /* é»˜è®¤æ‰‹å‹ */
        }
        canvas { 
            /* æ–°å¢ï¼šç»å¯¹å®šä½ï¼Œç¡®ä¿ (0,0) åæ ‡ä¸¥ä¸åˆç¼ */
            position: absolute;
            top: 0;
            left: 0;
            
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5); 
            display: block;
            transform-origin: 0 0; 
        }

        .color-swatch-btn {
            width: 24px; height: 24px; border-radius: 4px; border: 2px solid #4b5563; cursor: pointer; transition: transform 0.1s, border-color 0.1s;
        }
        .color-swatch-btn:hover { transform: scale(1.1); border-color: #9ca3af; }

        .modal-mask { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 9999; display: none; align-items: center; justify-content: center; }
        .modal-content { background: #1f2937; padding: 20px; border-radius: 8px; width: 400px; max-width: 90%; box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); border: 1px solid #374151; }
        
        .confirm-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 10000; display: none; align-items: center; justify-content: center; }
        .confirm-box { background: #1f2937; border: 1px solid #4b5563; padding: 20px; border-radius: 8px; text-align: center; width: 300px; }

        .rt-btn {
            background-color: #374151; color: #d1d5db; border: 1px solid #4b5563; padding: 2px 8px; border-radius: 4px; font-size: 12px; font-weight: bold; cursor: pointer; transition: all 0.1s;
        }
        .rt-btn:hover { background-color: #4b5563; color: white; }
        .rt-btn:active { transform: translateY(1px); }
        /* é’ˆå¯¹å³ä¾§è¾¹æ æŒ‰é’®çš„å¾®è°ƒ */
        .w-12 .rt-btn {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            font-size: 14px;
            border-radius: 6px;
        }

        /* æ‚¬åœæ•ˆæœå¢å¼º */
        .w-12 .rt-btn:hover {
            transform: scale(1.05);
            background-color: #4b5563;
        }
    </style>
</head>
<body class="flex flex-col h-screen">

    <div id="loadingMask" class="modal-mask" style="flex-direction: column; color: white;">
        <div class="text-xl font-bold mb-2">æ­£åœ¨åŠ è½½å­—ä½“...</div>
    </div>

    <!-- Confirm Modal -->
    <div id="confirmModal" class="confirm-overlay">
        <div class="confirm-box">
            <h3 class="text-white font-bold text-lg mb-4">ç¡®è®¤å…¨å±€æ“ä½œ</h3>
            <p id="confirmMessage" class="text-gray-300 text-sm mb-6">...</p>
            <div class="flex justify-center gap-4">
                <button id="btnConfirmNo" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 rounded text-white text-sm">
                    å–æ¶ˆï¼ˆä¸è¿›è¡Œä¿®æ”¹ï¼‰
                </button>
                <button id="btnConfirmYes" class="px-4 py-2 bg-blue-600 hover:bg-blue-500 rounded text-white text-sm font-bold">
                    ç¡®å®šå…¨éƒ¨åº”ç”¨
                </button>
            </div>
        </div>
    </div>


    <!-- Top Toolbar -->
    

    <div class="h-16 bg-gray-900 border-b border-gray-700 flex items-center px-4 gap-4 flex-none z-10 shadow-md overflow-x-auto">

        <div class="flex gap-2 items-center flex-shrink-0">
            <div class="flex flex-col gap-1">
                <label class="bg-blue-600 hover:bg-blue-500 rounded px-2 py-0.5 cursor-pointer text-white text-[10px] font-bold">
                    å• JSON <input type="file" id="jsonInput" accept=".json" class="hidden">
                </label>
                <label class="bg-green-600 hover:bg-green-500 rounded px-2 py-0.5 cursor-pointer text-white text-[10px] font-bold">
                    å•å›¾ç‰‡ <input type="file" id="imageInput" accept="image/*" class="hidden">
                </label>
                <label class="bg-teal-600 hover:bg-teal-500 rounded px-2 py-0.5 cursor-pointer text-white text-[10px] font-bold">
                    å•ä¿®å¤å›¾ <input type="file" id="repairInput" accept="image/*" class="hidden">
                </label>
            </div>
            
            <div class="w-px h-8 bg-gray-700 mx-1"></div>

            <div class="flex flex-col gap-1">
                <label class="bg-indigo-600 hover:bg-indigo-500 rounded px-2 py-0.5 cursor-pointer text-white text-[10px] font-bold">
                    æ‰¹é‡ JSON <input type="file" id="jsonFolderInput" webkitdirectory directory multiple class="hidden">
                </label>
                <label class="bg-purple-600 hover:bg-purple-500 rounded px-2 py-0.5 cursor-pointer text-white text-[10px] font-bold">
                    æ‰¹é‡å›¾ç‰‡ <input type="file" id="imageFolderInput" webkitdirectory directory multiple class="hidden">
                </label>
                <label class="bg-emerald-600 hover:bg-emerald-500 rounded px-2 py-0.5 cursor-pointer text-white text-[10px] font-bold">
                    æ‰¹é‡ä¿®å¤ <input type="file" id="repairFolderInput" webkitdirectory directory multiple class="hidden">
                </label>                
            </div>
        </div>

        <div id="batchNav" class="hidden items-center gap-1 bg-gray-800 px-2 py-1 rounded-lg border border-gray-700 ml-2">
            <button id="btnLastPage" onclick="jumpToPage(matchedFiles.length - 1)" class="p-1 hover:bg-gray-700 rounded text-white disabled:opacity-30 disabled:cursor-not-allowed" title="æœ€åä¸€é¡µ">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19l-7-7 7-7M20 19l-7-7 7-7"/></svg>
            </button>
            <button id="btnNextPage" onclick="navigateFiles(1)" class="p-1 hover:bg-gray-700 rounded text-white disabled:opacity-30 disabled:cursor-not-allowed" title="ä¸‹ä¸€é¡µ (â†)">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>
            </button>
            
            <div class="flex items-center gap-1 mx-1">
                <input type="number" id="pageInput" class="w-12 bg-gray-900 border border-gray-600 rounded text-center text-xs text-white h-6">
                <span id="fileCounterTotal" class="text-[10px] text-gray-400">/ 0</span>
            </div>

            <button id="btnPrevPage" onclick="navigateFiles(-1)" class="p-1 hover:bg-gray-700 rounded text-white disabled:opacity-30 disabled:cursor-not-allowed" title="ä¸Šä¸€é¡µ (â†’)">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg>
            </button>
            <button id="btnFirstPage" onclick="jumpToPage(0)" class="p-1 hover:bg-gray-700 rounded text-white disabled:opacity-30 disabled:cursor-not-allowed" title="ç¬¬ä¸€é¡µ">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M4 5l7 7-7 7"/></svg>
            </button>
        </div>

        <div class="flex-grow"></div>

        <div class="flex items-center gap-2 bg-gray-800 px-3 py-1.5 rounded-full border border-gray-700 shadow-sm flex-shrink-0">
            <button id="btnExport" class="px-2 py-1 bg-indigo-600 hover:bg-indigo-500 text-white text-xs rounded">ğŸ’¾ å¯¼å‡º</button>
            <div class="w-px h-4 bg-gray-600"></div>
            <div class="flex items-center gap-3 bg-gray-800 px-3 py-1 rounded-full border border-gray-700">
                <label class="checkbox-label text-xs text-gray-300 flex items-center gap-1 cursor-pointer">
                    <input type="checkbox" id="showBlocksCb" class="accent-blue-600" checked>æ€»æ¡†
                </label>
                <label class="checkbox-label text-xs text-gray-300 flex items-center gap-1 cursor-pointer">
                    <input type="checkbox" id="showLinesCb" class="accent-green-600" checked>è¡Œæ¡†
                </label>
                <label class="checkbox-label text-xs text-gray-300 flex items-center gap-1 cursor-pointer">
                    <input type="checkbox" id="showTextCb" class="accent-yellow-600" checked>æ–‡å­—
                </label>
            </div>
            <div class="w-px h-4 bg-gray-600"></div>
            <div class="flex bg-gray-700 rounded p-0.5">
                <button id="btnTrans" class="px-2 py-0.5 text-xs rounded bg-blue-600 text-white">è¯‘</button>
                <button id="btnOriginal" class="px-2 py-0.5 text-xs rounded text-gray-300">åŸ</button>
            </div>
        </div>
        <!-- Style Controls -->
        <div class="flex items-center gap-3 bg-gray-800 p-1.5 rounded-lg border border-gray-700 flex-shrink-0">
             <div class="flex flex-col">
                <span class="text-[9px] text-gray-400 uppercase tracking-wider">Font</span>
                <div class="flex gap-1">
                    <select id="fontSelect" class="bg-gray-900 border border-gray-600 text-white text-xs rounded px-1 py-0.5 outline-none focus:border-blue-500 w-24 h-6">
                        <option value='"Noto Sans SC", sans-serif'>æ€æºé»‘ä½“</option>
                        <option value='"Source Han Sans SC", "Source Han Sans CN", "Noto Sans SC", sans-serif'>æ€æºé»‘ä½“ (æœ¬åœ°)</option>
                        <option value='"Microsoft YaHei", sans-serif'>å¾®è½¯é›…é»‘</option>
                        <option value='"SimHei", sans-serif'>é»‘ä½“</option>
                        <option value='"KaiTi", serif'>æ¥·ä½“</option>
                        <option value="custom">æ‰‹åŠ¨...</option>
                    </select>
                    <label class="bg-purple-600 hover:bg-purple-500 text-white text-[10px] rounded px-2 flex items-center cursor-pointer" title="åŠ è½½æœ¬åœ°å­—ä½“">
                        <span>+</span><input type="file" id="fontFileInput" accept=".ttf,.otf,.woff" class="hidden">
                    </label>
                </div>
            </div>
            <input type="text" id="customFontInput" class="hidden bg-gray-900 border border-gray-600 text-white text-xs rounded px-2 py-0.5 w-20 h-6" placeholder="å­—ä½“å">

            <div class="flex flex-col">
                <span class="text-[9px] text-gray-400 uppercase tracking-wider font-bold text-yellow-500">Size</span>
                <div class="flex gap-1">
                    <input type="number" id="fontSizeInput" disabled step="0.5" class="bg-gray-900 border border-gray-600 text-white text-xs rounded px-1 py-0.5 w-12 h-6 text-center focus:border-yellow-500 transition-colors" placeholder="-">
                    <button onclick="applyAutoFontSize()" class="bg-yellow-600 hover:bg-yellow-500 text-white text-[10px] rounded px-1 flex items-center justify-center border border-yellow-700 w-6 h-6" title="å•é¡µè‡ªåŠ¨å­—å·">
                        è‡ª
                    </button>
                </div>
            </div>
            <div class="flex flex-col mx-1">
                <span class="text-[9px] text-gray-400 uppercase tracking-wider font-bold text-blue-400">Weight</span>
                <select id="fontWeightSelect" class="bg-gray-900 border border-gray-600 text-white text-xs rounded px-1 py-0.5 outline-none focus:border-blue-500 h-6 w-16">
                    <option value="400">å¸¸è§„</option>
                    <option value="700" selected>ç²—ä½“</option> <option value="900">ç‰¹ç²—</option>
                    <option value="100">ç»†ä½“</option>
                </select>
            </div>

            <div class="flex flex-col">
                <span class="text-[9px] text-gray-400 uppercase tracking-wider" title="å¯¹é½æ–¹å¼">Align</span>
                <div class="flex gap-1">
                    <select id="textAlignSelect" class="bg-gray-900 border border-gray-600 text-white text-xs rounded px-1 py-0.5 outline-none focus:border-blue-500 h-6 w-20">
                        <option value="block-center-top" selected>å—å±…ä¸­</option>
                        <option value="block-top">å—é¦–å¯¹é½</option>
                        <option value="block-bottom">å—å°¾å¯¹é½</option>
                        <option value="column-center">å•åˆ—å±…ä¸­</option>
                    </select>
                    <button id="btnForceAlign" class="bg-gray-700 hover:bg-blue-600 text-white rounded px-1 flex items-center justify-center border border-gray-600 transition-colors w-6 h-6" title="å¼ºåˆ¶åº”ç”¨å½“å‰æ’ç‰ˆåˆ°æ‰€æœ‰æ¡†">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-3 h-3">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0013.803-3.7M4.031 9.865a8.25 8.25 0 0113.803-3.7l3.181 3.182m0-4.991v4.99" />
                        </svg>
                    </button>
                </div>
            </div>

            <div class="flex flex-col">
                <span class="text-[9px] text-gray-400 uppercase tracking-wider" title="è¡Œé—´è·">Line H</span>
                <div class="flex gap-1">
                    <input type="number" id="lineSpacingInput" disabled step="0.01" 
                        class="bg-gray-900 border border-gray-600 text-white text-xs rounded px-1 py-0.5 w-12 h-6 text-center focus:border-blue-500" 
                        placeholder="Auto">
                    <button onclick="applyAutoLineSpacing()" 
                        class="bg-blue-600 hover:bg-blue-500 text-white text-[10px] rounded px-1 flex items-center justify-center border border-blue-700 w-6 h-6" 
                        title="å•é¡µè‡ªåŠ¨è¡Œè·ï¼Œè¯·è¿›è¡Œå•é¡µè‡ªåŠ¨å­—å·åå†ä½¿ç”¨å•é¡µè‡ªåŠ¨è¡Œè·">
                        è‡ª
                    </button>
                </div>
            </div>
            <div class="flex flex-col">
                <span class="text-[9px] text-gray-400 uppercase tracking-wider" title="å­—é—´è·">Letter S</span>
                <input type="number" id="letterSpacingInput" disabled step="0.01" 
                    class="bg-gray-900 border border-gray-600 text-white text-xs rounded px-1 py-0.5 w-12 h-6 text-center focus:border-blue-500" 
                    placeholder="0.00">
            </div>
            <div class="flex flex-col ml-2 items-center justify-center">
                <span class="text-[9px] text-gray-400 uppercase tracking-wider" title="è‡ªåŠ¨å°†2-4ä½æ•°å­—è½¬ä¸ºçºµä¸­æ¨ª">Auto TCY</span>
                <input type="checkbox" id="autoTcyCb" checked class="h-4 w-4 mt-1 accent-blue-600 cursor-pointer">
            </div>

            <div class="flex items-center gap-2 ml-1">
                <div class="flex flex-col items-center">
                    <span class="text-[9px] text-gray-400">Fill</span>
                    <div id="btnFillColor" class="color-swatch-btn" style="background-color: #000000;" title="ç‚¹å‡»ä¿®æ”¹å­—ä½“é¢œè‰²"></div>
                    <input type="color" id="nativeFillPicker" class="hidden">
                </div>
                <div class="w-px h-6 bg-gray-600 mx-1"></div>
                <!-- Stroke Controls (å¸¦å¼€å…³) -->
                <div class="flex flex-col items-center">
                    <span class="text-[9px] text-gray-400">Stroke</span>
                    <div class="flex items-center gap-1">
                        <input type="checkbox" id="strokeEnable" checked class="h-3 w-3 cursor-pointer" title="å¯ç”¨/ç¦ç”¨æè¾¹">
                        <div id="btnStrokeColor" class="color-swatch-btn" style="background-color: #ffffff;" title="ç‚¹å‡»ä¿®æ”¹æè¾¹é¢œè‰²"></div>
                        <input type="color" id="nativeStrokePicker" class="hidden">
                        <input type="number" id="strokeWidthInput" step="0.05" min="0" max="5" value="0.2" 
                            class="bg-gray-900 border border-gray-600 text-white text-xs rounded px-1 py-0.5 w-14 h-6 text-center focus:border-blue-500 transition-colors outline-none" 
                            title="æè¾¹ç²—ç»† (0.2 = 20% å­—å·)">
                        <label class="flex items-center cursor-pointer ml-1" title="åœ†è§’æè¾¹ (Round Join)">
                            <input type="checkbox" id="strokeRound" checked class="h-3 w-3 accent-blue-600">
                            <span class="text-[9px] text-gray-400 ml-0.5">åœ†</span>
                        </label>
                        <!-- [æ–°å¢] å¡«å­”/å¼ºåŠ›æè¾¹å¼€å…³ -->
                        <label class="flex items-center cursor-pointer ml-1" title="å¡«å­” (å¤šå±‚å åŠ ï¼Œè§£å†³ç©ºå¿ƒé—®é¢˜ï¼Œä»…å¯¹é€‰ä¸­æ¡†ç”Ÿæ•ˆ)">
                            <input type="checkbox" id="fillHolesCb" class="h-3 w-3 accent-red-500">
                            <span class="text-[9px] text-gray-400 ml-0.5">å¡«å­”</span>
                        </label>
                    </div>
                </div>

                <div class="flex flex-col items-center ml-2 border-l border-gray-700 pl-2">
                    <span class="text-[9px] text-gray-400">Blur</span>
                    <div class="flex items-center gap-1">
                        <input type="checkbox" id="blurEnable" class="h-3 w-3 cursor-pointer">
                        <input type="number" id="blurSizeInput" step="0.01" min="0" max="1" value="0.1"
                            class="bg-gray-900 border border-gray-600 text-white text-xs rounded px-1 py-0.5 w-14 h-6 text-center focus:border-blue-500 transition-colors outline-none" 
                            title="å‘å…‰å€ç‡ (0.1 = 10% å­—å·)"> 
                        <div id="btnBlurColor" class="color-swatch-btn" style="background-color: #000000;" title="ç‚¹å‡»ä¿®æ”¹å‘å…‰é¢œè‰²"></div>
                        <input type="color" id="nativeBlurPicker" class="hidden">
                    </div>
                </div>
            </div>
            
        </div>


    </div>

    <div class="flex flex-grow overflow-hidden">
        <div class="w-96 bg-gray-800 border-r border-gray-700 flex flex-col flex-none z-0 shadow-xl relative">
            
            <div class="h-10 bg-gray-900 border-b border-gray-700 flex items-center justify-between px-3 flex-none">
                <span class="text-xs font-bold text-gray-400" id="sidebarStatus">æœªé€‰æ‹©åŒºåŸŸ</span>
                <div class="flex gap-1">
                    <button onclick="navigateRegion(-1)" class="px-2 py-0.5 bg-gray-700 hover:bg-gray-600 rounded text-xs text-white" title="ä¸Šä¸€ä¸ª (Aé”®)">Prev</button>
                    <button onclick="navigateRegion(1)" class="px-2 py-0.5 bg-gray-700 hover:bg-gray-600 rounded text-xs text-white" title="ä¸‹ä¸€ä¸ª (Dé”®)">Next</button>
                </div>
            </div>

            <div id="editorContainer" class="flex-col flex-grow p-3 flex transition-opacity duration-200">
                
                <div class="flex flex-wrap gap-1 mb-2 p-1 bg-gray-900 rounded border border-gray-700 flex-none">
                    <button class="rt-btn" onclick="insertTag('b')" title="åŠ ç²— [b]">[B]</button>
                    <button class="rt-btn" onclick="insertTagWithParam('i', 'è§’åº¦', '15')" title="æ–œä½“ [i=15]"><span style="display: inline-block; transform: skewX(-20deg);">[I]</span></button>
                    <button class="rt-btn" onclick="insertTagWithParam('v', 'å‚ç›´åˆ‡å˜', '15')" title="å‚ç›´åˆ‡å˜ [v=15]"><span style="display: inline-block; transform: skewY(-15deg);">[V]</span></button>
                    <button class="rt-btn text-green-300" onclick="insertTagWithParam('rot', 'è§’åº¦', '15')" title="æ—‹è½¬ [rot=15]">[R]</button>
                    <button class="rt-btn text-orange-400" onclick="insertTag('m')" title="æ°´å¹³ç¿»è½¬ [m]">[Mh]</button>
                    <button class="rt-btn text-pink-400" onclick="insertTag('mv')" title="ç«–å‘ç¿»è½¬ [mv]">[Mv]</button>
                    <button class="rt-btn text-yellow-300" onclick="insertTagWithParam('k', 'é—´è·', '0.2')" title="å­—è·è°ƒæ•´ [k=0.5]">[Sp]</button>
                    <button class="rt-btn text-yellow-300" onclick="insertTagWithParam('x', 'Xä½ç§»', '5')" title="æ°´å¹³ä½ç§» [x=5]">[X]</button>
                    <button class="rt-btn text-yellow-300" onclick="insertTagWithParam('y', 'Yä½ç§»', '-5')" title="å‚ç›´ä½ç§» [y=-5]">[Y]</button>
                    <button class="rt-btn" onclick="insertTag('t')" title="çºµä¸­æ¨ª [t]">[T]</button>
                    <button class="rt-btn" onclick="insertTag('d')" title="ç€é‡å· [d]">[â€¢]</button>
                    <button class="rt-btn" onclick="insertTagWithParam('s', 'å€ç‡', '1.2')" title="å­—å· [s=1.2]">[Sz]</button>
                    <button class="rt-btn" onclick="insertTagWithParam('f', 'å­—ä½“', 'SimSun')" title="å­—ä½“ [f=SimSun]">[Fn]</button>
                    <button class="rt-btn" onclick="insertTagWithParam('r', 'æ³¨éŸ³', '')" title="æ³¨éŸ³ [r=xxx]">[Ru]</button>
                    <button class="rt-btn text-red-400" onclick="clearTags()" title="æ¸…é™¤æ ‡ç­¾">[Cl]</button>
                </div>

                <div class="flex flex-col flex-1 min-h-0 mb-2">
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-[10px] text-blue-400 font-bold uppercase tracking-wider">Translation (è¯‘æ–‡)</span>
                    </div>
                    <textarea id="transEditArea" style="font-family: 'Noto Sans JP', sans-serif;" class="w-full h-full bg-gray-900 border border-gray-600 rounded p-2 text-white text-sm focus:border-blue-500 outline-none font-mono resize-none leading-relaxed" placeholder="è¾“å…¥è¯‘æ–‡å†…å®¹..."></textarea>
                </div>
                <div class="editor-label" style="font-size: 11px; color: #6b7280; margin: 8px 0 2px 0;">å¯è·¨æ¡†é¡µä¸´æ—¶æ–‡æœ¬</div>
                <textarea id="tempEditArea" 
                        class="editor-textarea" 
                        placeholder="å­˜æ”¾è‰ç¨¿æˆ–å¤‡é€‰è¯..." 
                        style="width: 100%; height: 50px; background: #111827; color: #9ca3af; border: 1px solid #374151; border-radius: 4px; padding: 4px; font-size: 12px; resize: vertical;"></textarea>
                <div class="flex flex-col flex-1 min-h-0 mb-3">
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-[10px] text-green-400 font-bold uppercase tracking-wider">Original OCR (åŸæ–‡)</span>
                        <span class="text-[9px] text-gray-500">æŒ‰è¡Œå¯¹åº”å°æ¡†</span>
                    </div>
                    <textarea id="origEditArea" style="font-family: 'Noto Sans JP', sans-serif;" class="w-full h-full bg-gray-900 border border-gray-600 rounded p-2 text-gray-300 text-sm focus:border-green-500 outline-none font-mono resize-none leading-relaxed" placeholder="åŸæ–‡å†…å®¹..."></textarea>
                </div>
                
                <div class="flex flex-wrap justify-between items-center flex-none gap-2">
                    <button id="btnResetSidebar" class="px-2 py-1.5 rounded bg-transparent text-red-400 hover:bg-red-900/40 border border-red-800 transition-colors text-[10px] font-bold active:scale-95">
                        â†º é‡ç½®
                    </button>
                    
                    <div class="flex gap-1">
                        <button onclick="recalibrateMode('slanted')" class="px-3 py-1.5 rounded bg-gray-700 hover:bg-purple-600 text-purple-300 border border-purple-500/30 transition-colors text-[10px] font-bold active:scale-95" title="æ–œï¼šæ™ºèƒ½åˆ†ææ–‡å­—å€¾æ–œåº¦å¹¶è‡ªåŠ¨å¯¹é½å¤–å£³">
                            æ–œ
                        </button>
                        <button onclick="recalibrateMode('straight')" class="px-3 py-1.5 rounded bg-gray-700 hover:bg-green-600 text-green-300 border border-green-500/30 transition-colors text-[10px] font-bold active:scale-95" title="ç›´ï¼šå°†è§’åº¦å¼ºåˆ¶å½’é›¶ï¼Œä½¿å¤–å£³å˜å›æ°´å¹³/å‚ç›´æ–¹å‘">
                            ç›´
                        </button>
                    </div>
                    <!--
                    <button id="btnSaveSidebar" class="flex-grow px-4 py-1.5 rounded bg-blue-600 hover:bg-blue-500 text-white text-[10px] font-bold shadow-lg active:scale-95">
                        æç¤ºï¼šshift+å·¦é”®å•å‡» å¯å¤šé€‰å¤šä¸ªè¡Œæ¡†
                    </button>
                    -->
                </div>
            </div>

        </div>
        <div class="flex-grow overflow-auto relative p-8" id="canvasContainer">
            <canvas id="mainCanvas"></canvas>
        </div>
        <div class="w-12 bg-gray-900 border-l border-gray-700 flex flex-col items-center py-3 gap-3 z-10 shadow-xl overflow-y-auto">
                <div class="flex flex-col gap-2">
                    <button id="batchProcessBtnRight" class="rt-btn text-blue-400 border-blue-500/30" title="ä¸€é”®å…¨è‡ªåŠ¨ï¼šæ‰§è¡Œæ–‡æœ¬æ›¿æ¢è§„åˆ™ + è‡ªåŠ¨å­—å·è¡Œè·">ä¸€</button>
                    <button id="replaceBtnRight" class="rt-btn" title="é’ˆå¯¹åŸæ–‡å¥—ç”¨å›ºå®šå–ä»£è§„åˆ™">æ›¿</button>
                    <!--
                    <button id="toggleTcyBtnRight" class="rt-btn" title="æ‰¹æ¬¡åˆ‡æ¢æ•°å­—æ¨ªæ’">å </button> 
                    -->
                    <button id="batchAutoFontSizeBtnRight" class="rt-btn" title="æ‰€æœ‰é¡µé¢æ‰§è¡Œè‡ªåŠ¨å­—å·ä¸è¡Œè·">è‡ª</button>
                </div>

                <div class="w-8 h-px bg-gray-700 mx-auto"></div>

                <div class="flex flex-col gap-2">
                    <button id="drawModeBtnRight" class="rt-btn text-yellow-500 border-yellow-500/30" title="æ‹–æ‹½æ–°å¢çŸ©å½¢æ¡†">ï¼‹</button>
                    <!--
                    <button id="autoFontSizeBtnRight" class="rt-btn" title="è‡ªåŠ¨å­—å·">å­—</button>
                    -->
                    <!--
                    <button id="fitBlockBtnRight" class="rt-btn" title="è‡ªé€‚åº”å¤–æ¡† (ä¿æŒé›¶åº¦)">é€‚</button>
                    <button id="skewBlockBtnRight" class="rt-btn text-purple-400 border-purple-500/30" title="è®¡ç®—è§’åº¦å¹¶å€¾æ–œå¤–æ¡†">æ–œ</button>
                    <button id="rectifyBtnRight" class="rt-btn" title="çŸ©å½¢åŒ–">çŸ©</button>
                    <button id="straightenBtnRight" class="rt-btn" title="æ‰¶æ­£">æ‰¶</button>
                    -->
                    <button id="mergeBtnRight" class="rt-btn" title="åˆå¹¶ (Shift+ç‚¹å‡»é€‰æ‹©å¤šè¡Œ)ï¼šå°†é€‰ä¸­çš„å¤šè¡Œå½’å¹¶ä¸ºä¸€ä¸ªæ€»æ¡†ï¼Œå¹¶ä¿ç•™å·²æœ‰çš„ç¿»è¯‘ç‰‡æ®µã€‚">åˆ</button>
                    <button id="splitBtnRight" class="rt-btn" title="æ‹†åˆ† (é€‰ä¸­è¯‘æ–‡å•è¡Œ)ï¼šå°†å½“å‰é€‰ä¸­çš„è¡Œä»æ€»æ¡†ä¸­ç²¾å‡†å‰¥ç¦»ï¼Œæˆç«‹ç‹¬ç«‹çš„æ–°æ¡†ã€‚">æ‹†</button>
                    <!--
                    <button id="reorderBtnRight" class="rt-btn" title="æ‰‹åŠ¨æ’åº">åº</button>
                    -->
                </div>

                <div class="w-8 h-px bg-gray-700 mx-auto"></div>

                <div class="flex flex-col gap-2">
                    <!--
                    <button id="editTextBtnRight" class="rt-btn" title="ä¿®æ”¹æ–‡å­—">æ–‡</button>
                    <button id="toggleRawBtnRight" class="rt-btn" title="æ˜¾ç¤º/éšè—åŸæ–‡å›¾ç‰‡">æ˜¾</button>
                    -->
                    <button id="editPropBtnRight" class="rt-btn" title="åˆ‡æ¢æ¨ªç«–æ’">å±</button>
                    <!--
                    <button id="editFontSizeBtnRight" class="rt-btn" title="æ”¹å­—å·">å·</button>
                    <button id="setAngleBtnRight" class="rt-btn" title="è®¾å®šè§’åº¦">è§’</button>
                    -->
                    <button id="deleteBtnRight" class="rt-btn text-red-500 border-red-500/30" title="åˆ é™¤é€‰ä¸­">åˆ </button>
                </div>
                <button onclick="toggleReplaceDialog()" class="px-2 py-1 bg-gray-700 hover:bg-gray-600 text-white text-xs rounded">ğŸ” æŸ¥æ‰¾æ›¿æ¢</button>
                <div id="replaceDialog" class="hidden fixed top-20 right-12 z-50 bg-gray-800 border border-gray-600 p-4 rounded-lg shadow-2xl w-80">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-white font-bold text-sm">è¯‘æ–‡æŸ¥æ‰¾æ›¿æ¢</h3>
                        <button onclick="toggleReplaceDialog()" class="text-gray-400 hover:text-white">âœ•</button>
                    </div>
                    <div class="space-y-3">
                        <div>
                            <label class="text-[10px] text-gray-400 block mb-1">æŸ¥æ‰¾å†…å®¹</label>
                            <input type="text" id="findInput" class="w-full bg-gray-900 border border-gray-700 rounded px-2 py-1 text-sm text-white focus:border-blue-500 outline-none">
                        </div>
                        <div>
                            <label class="text-[10px] text-gray-400 block mb-1">æ›¿æ¢ä¸º</label>
                            <input type="text" id="replaceInput" class="w-full bg-gray-900 border border-gray-700 rounded px-2 py-1 text-sm text-white focus:border-green-500 outline-none">
                        </div>
                        <div class="flex items-center gap-2">
                            <input type="checkbox" id="matchCase" class="accent-blue-600">
                            <label for="matchCase" class="text-[10px] text-gray-300">åŒºåˆ†å¤§å°å†™</label>
                        </div>
                        <div class="grid grid-cols-2 gap-2 mt-4">
                            <button onclick="executeReplace(false)" class="bg-blue-600 hover:bg-blue-500 text-white text-xs py-1.5 rounded font-bold">æ›¿æ¢å½“å‰é¡µ</button>
                            <button onclick="executeReplace(true)" class="bg-indigo-600 hover:bg-indigo-500 text-white text-xs py-1.5 rounded font-bold">å…¨éƒ¨æ›¿æ¢</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- 1. çŠ¶æ€å˜é‡ ---
        let showBlocks = true;
        let showLines = true;
        let showText = true;
        let activeRegionIndex = -1;
        let activeLineIndex = -1;
        // --- [æ–°å¢] ç»˜åˆ¶æ¨¡å¼çŠ¶æ€ ---
        let isDrawingMode = false;
        let drawStartPos = null;
        let tempDrawRect = null; // ç”¨äºå­˜å‚¨æ‹–æ‹½è¿‡ç¨‹ä¸­çš„ä¸´æ—¶æ¡† [x, y, w, h]
        // --- æ‰¹é‡æ¨¡å¼çŠ¶æ€ (å‚è€ƒ Angle) ---
        // --- [æ–°å¢] çŠ¶æ€å˜é‡ ---
        let currentRepairImage = null;
        let repairFiles = null;
        let imageFiles = null;
        let jsonFiles = null;
        let matchedFiles = []; // å­˜å‚¨ {image, jsonName, data}
        let currentFileIndex = -1;
        // --- [æ–°å¢] å¤šé€‰çŠ¶æ€ ---
        let selectedItems = []; // å­˜å‚¨å¯¹è±¡æ ¼å¼ï¼š{ regionIdx, lineIdx }
        let isShiftMultiSelect = false; // ã€æ–°å¢ã€‘ç”¨äºè®°å½•å½“å‰æ˜¯å¦å¤„äº Shift å¤šé€‰æ¨¡å¼
        // State
        let currentJson = null, currentImage = null, regions = [];
        let displayMode = 'translation', currentFileName = "image";

        let isSpacePressed = false;
        window.addEventListener('keydown', (e) => { if (e.code === 'Space') isSpacePressed = true; });
        window.addEventListener('keyup', (e) => { if (e.code === 'Space') isSpacePressed = false; });

        let activeFontFamily = '"Noto Sans SC", sans-serif';
        let activeFontWeight = "700"; // [æ–°å¢] é»˜è®¤å­—é‡ (700=Bold)
        let activeTextColor = "#000000";  // é»‘è‰²
        let activeStrokeColor = "#ffffff"; 
        let activeStrokeWidth = 0.2; 
        let activeStrokeEnabled = true;
        let activeTextAlign = 'block-center-top';  
        let loadedCustomFonts = [];
        // ... åŸæœ‰å˜é‡ ...

        // [æ–°å¢] è§†å›¾çŠ¶æ€ï¼šç¼©æ”¾æ¯”ä¾‹ã€åç§»é‡
        let viewState = { scale: 1, x: 0, y: 0, isPanning: false, startX: 0, startY: 0 };

        // Modal Logic State
        let pendingGlobalValue = null;
        let pendingGlobalType = null; 

        // Transform State
        let transformState = { dragging: false, action: null, handleIndex: -1, startMouse: {x: 0, y: 0}, startBox: null, startBoxAngle: 0, center: {x: 0, y: 0} };

        // [æ–°å¢] ç”¨äºè®°å½•æ‰“å¼€å–è‰²å™¨é‚£ä¸€åˆ»é€‰ä¸­çš„æ˜¯è°
        let colorPickTargetIndex = -1;

        let activeAutoTcy = true; // é»˜è®¤å¼€å¯
        
        // --- 2. è·å– DOM å…ƒç´  (ç»Ÿä¸€æ”¾åœ¨è¿™é‡Œï¼Œè§£å†³åˆå§‹åŒ–é¡ºåºé—®é¢˜) ---
        const sidebarStatus = document.getElementById('sidebarStatus');
        const fontWeightSelect = document.getElementById('fontWeightSelect'); // è§£å†³æŠ¥é”™çš„æ ¸å¿ƒ
        const fontSizeInput = document.getElementById('fontSizeInput');
        const lineSpacingInput = document.getElementById('lineSpacingInput');
        const letterSpacingInput = document.getElementById('letterSpacingInput');
        const textAlignSelect = document.getElementById('textAlignSelect');
        const transEditArea = document.getElementById('transEditArea');
        const origEditArea = document.getElementById('origEditArea');
        const showBlocksCb = document.getElementById('showBlocksCb');
        const showLinesCb = document.getElementById('showLinesCb');
        const showTextCb = document.getElementById('showTextCb');
        const mainCanvas = document.getElementById('mainCanvas');
        let ctx = mainCanvas.getContext('2d');
        // è·å–æ–°æ ä½
        const tempEditArea = document.getElementById('tempEditArea');
        const savedGlobalTemp = localStorage.getItem('mtu_global_temp_text') || "";

        // å…¶ä»–è·å–å…ƒç´ çš„è¯­å¥
        const jsonFolderInput = document.getElementById('jsonFolderInput');
        const imageFolderInput = document.getElementById('imageFolderInput');
        const batchNav = document.getElementById('batchNav');
        const pageInput = document.getElementById('pageInput');
        const fileCounterTotal = document.getElementById('fileCounterTotal');        

        const jsonInput = document.getElementById('jsonInput');
        const imageInput = document.getElementById('imageInput');
        const fontFileInput = document.getElementById('fontFileInput');
        const sidebarList = document.getElementById('sidebarList');
        const loadingMask = document.getElementById('loadingMask');
        
        // Controls
        const fontSelect = document.getElementById('fontSelect');
        const customFontInput = document.getElementById('customFontInput');
        const strokeEnableCb = document.getElementById('strokeEnable');
        const strokeWidthInput = document.getElementById('strokeWidthInput');
        const btnForceAlign = document.getElementById('btnForceAlign'); 
        const showBoxesCb = document.getElementById('showBoxes');
        const btnTrans = document.getElementById('btnTrans');
        const btnOriginal = document.getElementById('btnOriginal');
        const btnExport = document.getElementById('btnExport');
        const fillHolesCb = document.getElementById('fillHolesCb'); // [æ–°å¢]
        // --- æ–°å¢å˜é‡ (åœ¨é¡¶éƒ¨å®šä¹‰) ---
        const btnResetSidebar = document.getElementById('btnResetSidebar');
        // Color & Modal Elements
        const confirmModal = document.getElementById('confirmModal');
        const btnConfirmYes = document.getElementById('btnConfirmYes');
        const btnConfirmNo = document.getElementById('btnConfirmNo');
        const confirmMessage = document.getElementById('confirmMessage');
        
        const btnFillColor = document.getElementById('btnFillColor');
        const btnStrokeColor = document.getElementById('btnStrokeColor');
        const colorModalTitle = document.getElementById('colorModalTitle');
        // --- [æ–°å¢] åŸç”Ÿé¢œè‰²é€‰æ‹©å™¨é€»è¾‘ ---

        const nativeFillPicker = document.getElementById('nativeFillPicker');
        const nativeStrokePicker = document.getElementById('nativeStrokePicker');
        const nativeBlurPicker = document.getElementById('nativeBlurPicker');

        const drawModeBtnRight = document.getElementById('drawModeBtnRight');

        const mergeBtnRight = document.getElementById('mergeBtnRight');
        // ç»‘å®šå³ä¾§è¾¹æ â€œæ‹†â€æŒ‰é’®
        const splitBtnRight = document.getElementById('splitBtnRight');
        // è·å–æ‰¹é‡å¤„ç†æŒ‰é’®
        const batchAutoFontSizeBtnRight = document.getElementById('batchAutoFontSizeBtnRight');
        // ç»‘å®šå³ä¾§è¾¹æ â€œå±â€æŒ‰é’®
        const editPropBtnRight = document.getElementById('editPropBtnRight');
        const replaceBtnRight = document.getElementById('replaceBtnRight');


        // --- 1. Constants ---
        const CHARS_DYNAMIC_CENTER = "-â€“â€”=â‰ â‰ˆâ‰¡+Ã—Ã·â€¦ã€œ()[]{}<>â€•ã€ˆã€‰ï¼ˆï¼‰ã€ã€‘ã€Šã€‹ï½›ï½ãƒ¼ï½ï¼ï¼~;";
        const CHARS_OPENING = "ã€ˆï¼ˆã€ã€Šã€ã€Œï½›ã€"; // å‰æ‹¬å·ï¼šå¢¨è¿¹åœ¨ä¸‹/åœ¨å³
        const CHARS_CLOSING = "ã€‰ï¼‰ã€‘ã€‹ã€ã€ï½ã€Ÿ"; // åæ‹¬å·ï¼šå¢¨è¿¹åœ¨ä¸Š/åœ¨å·¦
        const CHARS_PUNCT   = "ï¼Œã€‚ã€ï¼ï¼Ÿï¼šï¼›";           // åŸºç¡€æ ‡ç‚¹ï¼šå¢¨è¿¹åœ¨å³ä¸Šï¼ˆç«–æ’ï¼‰/åœ¨å·¦ä¸‹ï¼ˆæ¨ªæ’ï¼‰
        // ä¸å‚ä¸æ°´å¹³å¼ºåˆ¶å±…ä¸­çš„ç¬¦å·
        const CHARS_NO_CENTER_H = "ã€ã€Ÿã€ã€ã€Œã€";

        const CHARS_SYMMETRIC_HALF = "ã€ˆã€‰ï¼ˆï¼‰ã€ã€‘ã€Šã€‹ã€ã€ã€Œã€ï½›ï½ã€ã€Ÿ";
        const ROTATED_LETTERS_NUMBERS = "qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM0123456789!?:;" + CHARS_DYNAMIC_CENTER;
        const CHARS_UPRIGHT_CENTER = "ï¼ï¼Ÿï¼šï¼›.";
        const CHARS_TO_ROTATE = "()[]{}<>ã€ˆã€‰ï¼ˆï¼‰ã€ã€‘ã€Šã€‹ã€ã€ã€Œã€ï½›ï½ï½¢ï½£ã€ã€Ÿ";
        const CHARS_VERTICAL_COMPRESSION = "ï¼Œã€‚ã€Â·ãƒ»ã€ˆã€‰ï¼ˆï¼‰ã€ã€‘ã€Šã€‹ã€ã€ã€Œã€ï½›ï½ï½¢ï½£ã€ã€Ÿ";
        const CHARS_HORIZONTAL_COMPRESSION = "ï¼Œã€‚ã€ï¼›ï¼šï¼Ÿï¼Â·ãƒ»ã€ˆã€‰ï¼ˆï¼‰ã€ã€‘ã€Šã€‹ã€ã€ã€Œã€ï½›ï½ï½¢ï½£ã€ã€Ÿ";
        const CHARS_PUNCTUATION_TOP_RIGHT = "ã€ã€‚ï¼Œ";
        const HALF_WIDTH_PUNCTUATION_TOP_RIGHT = "ï½¤,";
        const CHARS_SMALL_KANA_TOP_RIGHT = "ã‚ƒã‚…ã‚‡ã£ããƒã…ã‡ã‰ãƒ£ãƒ¥ãƒ§ãƒƒã‚¡ã‚£ã‚¥ã‚§ã‚©ãƒµãƒ¶";
        const CHARS_VISUAL_CENTER = "ï¼ï¼Ÿï¼šï¼›";


        // æ ‡ç‚¹å‹ç¼©ä¸æ—‹è½¬å¸¸é‡ (æºè‡ªç¬¬äºŒä¸ªæ–‡ä»¶)
        const CHARS_VERTICAL_COMPRESSION_ORIG = "ï¼Œã€‚ã€ï¼›ï¼šï¼Ÿï¼Â·ãƒ»ã€ˆã€‰ï¼ˆï¼‰ã€ã€‘ã€Šã€‹ã€ã€ã€Œã€ï½›ï½ï½¢ï½£ã€ã€Ÿ";
        const CHARS_HORIZONTAL_COMPRESSION_ORIG = "ï¼Œã€‚ã€ï¼›ï¼šï¼Ÿï¼Â·ãƒ»ã€ˆã€‰ï¼ˆï¼‰ã€ã€‘ã€Šã€‹ã€ã€ã€Œã€ï½›ï½ï½¢ï½£ã€ã€Ÿ";
        const CHARS_TO_ROTATE_ORIG = "()[]{}<>ã€ˆã€‰ï¼ˆï¼‰ã€ã€‘ã€Šã€‹ã€ã€ã€Œã€ï½›ï½ï½¢ï½£ã€ã€Ÿ-";

        // ä¸¥æ ¼å¤åˆ» Angle åŸå§‹æ›¿æ¢è§„åˆ™
        const replacements = [
            ["ï¼ï¼ï¼ãƒ»", "â€¦"], ["â€¦ãƒ»", "â€¦"], ["ï¼ï¼ï¼", "â€¦"], ["ï¼ï¼", "â€¦"],["ï¼ï¼ï¼", "â€¼"], ["ï¼ï¼", "â€¼"], ["ï¼ï¼Ÿ", "â‰"], ["ï¼", "ï¼"], ["ï¼š", "â€¦"], ["ï¼›", "â€¦"]
        ];

        const HANDLE_RADIUS = 6;
        const ROTATE_HANDLE_OFFSET = 30;

        // åˆ‡æ¢å¯¹è¯æ¡†æ˜¾ç¤º/éšè—
        function toggleReplaceDialog() {
            const dialog = document.getElementById('replaceDialog');
            dialog.classList.toggle('hidden');
            if (!dialog.classList.contains('hidden')) {
                document.getElementById('findInput').focus();
            }
        }

        /**
         * æ‰§è¡Œæ›¿æ¢é€»è¾‘
         * @param {boolean} isGlobal - æ˜¯å¦ä¸ºå…¨å±€ï¼ˆè·¨æ‰€æœ‰æ–‡ä»¶ï¼‰æ›¿æ¢
         */
        function executeReplace(isGlobal) {
            const findStr = document.getElementById('findInput').value;
            const replaceStr = document.getElementById('replaceInput').value;
            const matchCase = document.getElementById('matchCase').checked;

            if (!findStr) {
                alert("è¯·è¾“å…¥è¦æŸ¥æ‰¾çš„å†…å®¹");
                return;
            }

            let modifiedFilesCount = 0;
            let totalOccurrences = 0;

            // è¾…åŠ©å‡½æ•°ï¼šæ›¿æ¢æ–‡æœ¬
            const replaceInText = (text) => {
                if (!text) return text;
                // å¦‚æœä¸åŒºåˆ†å¤§å°å†™ï¼Œä½¿ç”¨æ­£åˆ™è¿›è¡Œå…¨å±€æ›¿æ¢
                const flags = matchCase ? 'g' : 'gi';
                const regex = new RegExp(findStr.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), flags);
                const count = (text.match(regex) || []).length;
                totalOccurrences += count;
                return text.replace(regex, replaceStr);
            };

            if (isGlobal && matchedFiles.length > 0) {
                // --- å…¨å±€æ›¿æ¢æ¨¡å¼ ---
                if (!confirm(`ç¡®å®šè¦åœ¨å…¨ä¹¦ ${matchedFiles.length} é¡µä¸­æ‰§è¡Œæ‰¹é‡æ›¿æ¢å—ï¼Ÿ`)) return;

                // å…ˆä¿å­˜å½“å‰é¡µåˆ°å†…å­˜
                if (matchedFiles[currentFileIndex]) {
                    matchedFiles[currentFileIndex].regions = JSON.parse(JSON.stringify(regions));
                }

                matchedFiles.forEach(file => {
                    let fileChanged = false;
                    file.regions.forEach(r => {
                        if (r.translation) {
                            const oldText = r.translation;
                            r.translation = replaceInText(r.translation);
                            if (oldText !== r.translation) fileChanged = true;
                        }
                    });
                    if (fileChanged) modifiedFilesCount++;
                });

                // é‡æ–°åŠ è½½å½“å‰é¡µä»¥åŒæ­¥ UI
                loadFile(currentFileIndex);
                alert(`æ›¿æ¢å®Œæˆï¼å…±ä¿®æ”¹äº† ${modifiedFilesCount} ä¸ªæ–‡ä»¶ï¼Œæ›¿æ¢äº† ${totalOccurrences} å¤„å†…å®¹ã€‚`);
            } else {
                // --- å•é¡µæ›¿æ¢æ¨¡å¼ ---
                let pageChanged = false;
                regions.forEach(r => {
                    if (r.translation) {
                        const oldText = r.translation;
                        r.translation = replaceInText(r.translation);
                        if (oldText !== r.translation) pageChanged = true;
                    }
                });

                if (pageChanged) {
                    draw();
                    // å¦‚æœå½“å‰æ­£é€‰ä¸­æŸä¸ªæ¡†ï¼Œæ›´æ–°ç¼–è¾‘åŒºæ–‡å­—
                    if (activeRegionIndex !== -1) {
                        setActiveRegion(activeRegionIndex);
                    }
                    alert(`å½“å‰é¡µæ›¿æ¢å®Œæˆï¼Œå…±æ›¿æ¢äº† ${totalOccurrences} å¤„ã€‚`);
                } else {
                    alert("æœªæ‰¾åˆ°åŒ¹é…å†…å®¹ã€‚");
                }
            }
        }



        // ä¿®æ­£åçš„ applyOriginalTextReplacement (çº¦ 170 è¡Œ)
        function applyOriginalTextReplacement() {
            const hasBatch = matchedFiles.length > 0;
            let modifiedCount = 0;

            const processRegions = (targetRegions) => {
                targetRegions.forEach(r => {
                    if (r.texts && Array.isArray(r.texts)) {
                        r.texts = r.texts.map(text => {
                            let newText = text;
                            replacements.forEach(([find, replace]) => {
                                while (newText.includes(find)) {
                                    newText = newText.replace(find, replace);
                                }
                            });
                            if (newText !== text) modifiedCount++;
                            return newText;
                        });
                    }
                });
            };

            if (hasBatch) {
                matchedFiles.forEach(file => processRegions(file.regions));
                // ã€å…³é”®ã€‘å¦‚æœæ˜¯æ‰¹é‡æ¨¡å¼ï¼Œå¿…é¡»é‡æ–°åŠ è½½å½“å‰é¡µæ¥åŒæ­¥å†…å­˜
                loadFile(currentFileIndex); 
            } else {
                processRegions(regions);
                // ã€å…³é”®ã€‘å¦‚æœæ˜¯å• JSONï¼Œæ‰‹åŠ¨åŒæ­¥ç¼–è¾‘æ¡†å¹¶é‡ç»˜
                if (activeRegionIndex !== -1) {
                    document.getElementById('origEditArea').value = regions[activeRegionIndex].texts.join('\n');
                }
                draw(); 
            }
            return modifiedCount;
        }


        // 3. ç»‘å®šâ€œä¸€â€æŒ‰é’®åŠŸèƒ½ï¼šæ›¿ + è‡ª
        const batchProcessBtnRight = document.getElementById('batchProcessBtnRight');

        // --- ä¸€é”®å…¨è‡ªåŠ¨åŠŸèƒ½ä¿®æ­£ç‰ˆ ---
        batchProcessBtnRight.onclick = async () => {
            const isBatch = matchedFiles.length > 0;
            const scope = isBatch ? `å…¨ä¹¦ (${matchedFiles.length}é¡µ)` : "å½“å‰é¡µ";
            
            if (!confirm(`ç¡®å®šè¦å¯¹ ${scope} æ‰§è¡Œä¸€é”®å…¨è‡ªåŠ¨å¤„ç†å—ï¼Ÿ\n(åŒ…å«ï¼šAngle è§„åˆ™æ›¿æ¢ + è‡ªåŠ¨å­—å· + è‡ªåŠ¨è¡Œè·)`)) return;

            if (isBatch) {
                // 1. ã€å…³é”®ï¼šå…ˆä¿å­˜ã€‘
                // å¿…é¡»å…ˆå°†å½“å‰å±å¹•ä¸Šï¼ˆregions å˜é‡é‡Œï¼‰çš„æœ€æ–°æ”¹åŠ¨åŒæ­¥åˆ°å†…å­˜æ•°ç»„ä¸­ï¼Œ
                // å¦åˆ™åç»­çš„æ–‡æœ¬æ›¿æ¢å’Œè‡ªåŠ¨å­—å·ä¼šåŸºäºæ—§æ•°æ®æ“ä½œã€‚
                if (matchedFiles[currentFileIndex]) {
                    matchedFiles[currentFileIndex].regions = JSON.parse(JSON.stringify(regions));
                }

                // 2. ã€æ‰§è¡Œâ€œæ›¿â€ã€‘
                // æ­¤æ—¶ applyOriginalTextReplacement ä¼šä¿®æ”¹å†…å­˜ä¸­æ‰€æœ‰é¡µï¼ˆåŒ…å«åˆšåˆšä¿å­˜çš„å½“å‰é¡µï¼‰çš„æ–‡æœ¬ã€‚
                applyOriginalTextReplacement();

                // 3. ã€æ‰§è¡Œâ€œè‡ªâ€ã€‘
                // éå†å†…å­˜ä¸­çš„æ‰€æœ‰æ–‡ä»¶ï¼ŒåŸºäºâ€œæ›¿æ¢åâ€çš„å¹²å‡€æ–‡æœ¬è®¡ç®—å­—å·å’Œè¡Œè·ã€‚
                matchedFiles.forEach(fileItem => {
                    fileItem.regions.forEach(r => {
                        const autoSize = calculateAutoFontSizeForRegion(r);
                        r.font_size = autoSize;
                        r.line_spacing = calculateAutoLineSpacing(r, autoSize);
                    });
                });
                
                // 4. ã€åˆ·æ–° UIã€‘
                // é‡æ–°åŠ è½½å½“å‰é¡µï¼Œç¡®ä¿ç”»é¢å’Œä¾§è¾¹æ æ˜¾ç¤ºçš„æ˜¯æ›¿æ¢å¹¶è®¡ç®—åçš„æœ€ç»ˆç»“æœã€‚
                loadFile(currentFileIndex); 
            } else {
                // --- å• JSON æ¨¡å¼é€»è¾‘ ---
                if (regions.length === 0) {
                    alert("æœªæ£€æµ‹åˆ°æœ‰æ•ˆçš„åŒºåŸŸæ•°æ®ã€‚");
                    return;
                }

                // 1. å…ˆæ‰§è¡Œæ–‡æœ¬æ›¿æ¢
                applyOriginalTextReplacement();
                
                // 2. ä¸ºå½“å‰é¡µæ‰€æœ‰æ¡†æ‰§è¡Œè‡ªåŠ¨æ’ç‰ˆä¼˜åŒ–
                regions.forEach(r => {
                    const autoSize = calculateAutoFontSizeForRegion(r);
                    r.font_size = autoSize;
                    r.line_spacing = calculateAutoLineSpacing(r, autoSize);
                });
                
                // 3. åŒæ­¥æ›´æ–°åŸæ–‡ç¼–è¾‘æ¡†çš„æ˜¾ç¤ºå†…å®¹
                if (activeRegionIndex !== -1) {
                    document.getElementById('origEditArea').value = regions[activeRegionIndex].texts.join('\n');
                }
                
                // 4. é‡ç»˜ç”»å¸ƒ
                draw(); 
            }

            // 5. è§†è§‰åé¦ˆé€»è¾‘ï¼ˆä¿æŒä¸å˜ï¼‰
            batchProcessBtnRight.innerText = "OK!";
            batchProcessBtnRight.classList.add('text-green-400', 'border-green-500');
            setTimeout(() => {
                batchProcessBtnRight.innerText = "ä¸€";
                batchProcessBtnRight.classList.remove('text-green-400', 'border-green-500');
            }, 1500);
        };

        // --- 3. ç»‘å®šç›‘å¬ (ä½¿ç”¨ change äº‹ä»¶) ---
        if(showBlocksCb) showBlocksCb.addEventListener('change', (e) => { showBlocks = e.target.checked; draw(); });
        if(showLinesCb) showLinesCb.addEventListener('change', (e) => { showLines = e.target.checked; draw(); });
        if(showTextCb) showTextCb.addEventListener('change', (e) => { showText = e.target.checked; draw(); });


        // 2. ç»‘å®šåˆ‡æ¢é€»è¾‘ (å»ºè®®æ”¾åœ¨è¿™é‡Œ)
        if (btnTrans) {
            btnTrans.onclick = () => { 
                displayMode = 'translation'; 
                toggleModeBtns(); 
                draw(); 
            };
        }

        if (btnOriginal) {
            btnOriginal.onclick = () => { 
                displayMode = 'original'; 
                toggleModeBtns(); 
                draw(); 
            };
        }


        // 3. æ ·å¼åˆ‡æ¢è¾…åŠ©å‡½æ•° (å¯ä»¥æ”¾åœ¨ draw å‡½æ•°é™„è¿‘æˆ–è„šæœ¬æœ«å°¾)
        function toggleModeBtns() {
            if (!btnTrans || !btnOriginal) return;
            btnTrans.className = `px-2 py-0.5 text-xs rounded ${displayMode === 'translation' ? 'bg-blue-600 text-white' : 'text-gray-300'}`;
            btnOriginal.className = `px-2 py-0.5 text-xs rounded ${displayMode === 'original' ? 'bg-blue-600 text-white' : 'text-gray-300'}`;
        }

        // 1. ä¸´æ—¶å®æ—¶ä¿å­˜
        tempEditArea.value = savedGlobalTemp;

        // 2. è¾“å…¥æ—¶ï¼šä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨ï¼Œä½†ä¸å­˜å…¥ region
        tempEditArea.oninput = () => {
            // å®ƒæ˜¯å…¨å±€çš„ï¼Œä¸å±äºä»»ä½• activeRegionIndex
            localStorage.setItem('mtu_global_temp_text', tempEditArea.value);
        };

        mergeBtnRight.onclick = () => {
            if (selectedItems.length < 2) {
                alert("è¯·æŒ‰ä½ Shift é”®è‡³å°‘é€‰ä¸­ä¸¤ä¸ª line æ¡†è¿›è¡Œåˆå¹¶");
                return;
            }

            const linesToMerge = [];
            selectedItems.forEach(item => {
                const r = regions[item.regionIdx];
                if (r && r.lines[item.lineIdx]) {
                    // 1. æå–ç¿»è¯‘ç‰‡æ®µ
                    const currentTransSegments = (r.translation || "").split('ã€BRã€‘');
                    // è·å–å½“å‰è¡Œçš„ç¿»è¯‘ï¼Œå¦‚æœæ²¡æœ‰ç¿»è¯‘åˆ™ä¿æŒä¸ºç©ºï¼Œä¸å›é€€åˆ°åŸæ–‡
                    const mySegment = currentTransSegments[item.lineIdx] || "";

                    linesToMerge.push({
                        coord: JSON.parse(JSON.stringify(r.lines[item.lineIdx])), 
                        text: (r.texts && r.texts[item.lineIdx]) ? r.texts[item.lineIdx] : "",
                        transSegment: mySegment.trim() // ã€ä¿®å¤ã€‘ï¼šå»æ‰å‰åçš„ä¸å¯è§ç©ºæ ¼
                    });
                }
            });

            const removeMap = new Map();
            selectedItems.forEach(item => {
                if (!removeMap.has(item.regionIdx)) removeMap.set(item.regionIdx, new Set());
                removeMap.get(item.regionIdx).add(item.lineIdx);
            });

            let newRegions = [];
            regions.forEach((r, rIdx) => {
                if (!removeMap.has(rIdx)) {
                    newRegions.push(r);
                } else {
                    const indicesToRemove = removeMap.get(rIdx);
                    const remainingLines = []; const remainingTexts = []; const remainingTrans = [];
                    const transSegments = (r.translation || "").split('ã€BRã€‘');

                    r.lines.forEach((line, lIdx) => {
                        if (!indicesToRemove.has(lIdx)) {
                            remainingLines.push(line);
                            if (r.texts) remainingTexts.push(r.texts[lIdx]);
                            remainingTrans.push(transSegments[lIdx] || "");
                        }
                    });

                    if (remainingLines.length > 0) {
                        r.lines = remainingLines;
                        if (r.texts) r.texts = remainingTexts;
                        r.translation = remainingTrans.join('ã€BRã€‘'); // å‰©ä½™éƒ¨åˆ†ä¿æŒè¯‘æ–‡
                        initRegionBox(r);
                        newRegions.push(r);
                    }
                }
            });

            // 2. åˆ›å»ºå…¨æ–°çš„åˆå¹¶åŒºå—
            const baseRegion = regions[selectedItems[0].regionIdx];
            const newMergedRegion = {
                ...JSON.parse(JSON.stringify(baseRegion)), 
                lines: linesToMerge.map(l => l.coord),
                texts: linesToMerge.map(l => l.text),
                
                // ã€æ ¸å¿ƒä¿®å¤ã€‘ï¼š
                // 1. ä½¿ç”¨ transSegment (å·²ä¿®æ”¹çš„ç¿»è¯‘) è€Œä¸æ˜¯ text (åŸæ–‡)
                // 2. ä½¿ç”¨ filter(s => s) è¿‡æ»¤æ‰ç”±äºæ‹†åˆ†äº§ç”Ÿçš„æ— æ•ˆç©ºè¡Œ
                translation: linesToMerge
                    .map(l => l.transSegment)
                    .filter(s => s !== "") // åªä¿ç•™æœ‰å†…å®¹çš„è¡Œï¼Œé˜²æ­¢å‡ºç°å¤šä½™ã€BRã€‘
                    .join('ã€BRã€‘'),
                    
                box: [] 
            };

            initRegionBox(newMergedRegion);
            newRegions.push(newMergedRegion);
            // ... (åç»­æ›´æ–°çŠ¶æ€é€»è¾‘ä¿æŒä¸å˜) ...
            regions = newRegions;
            selectedItems = []; 
            activeRegionIndex = regions.length - 1; 
            activeLineIndex = 0;
            setActiveRegion(activeRegionIndex);
            draw();
        };

        splitBtnRight.onclick = () => {
            if (activeRegionIndex === -1 || !regions[activeRegionIndex]) return;
            const r = regions[activeRegionIndex];
            if (!r.lines || r.lines.length <= 1) return;

            // 1. ç¡®å®šè¦æ‹†åˆ†çš„ç›®æ ‡è¡Œç´¢å¼•ï¼ˆä¼˜å…ˆå¤šé€‰ï¼Œå…¶æ¬¡å½“å‰ç‚¹ä¸­è¡Œï¼‰
            const selectedInCurrent = selectedItems.filter(item => 
                item.regionIdx === activeRegionIndex && item.lineIdx !== -1
            );
            
            let targetIndices = [];
            if (selectedInCurrent.length > 0) {
                targetIndices = selectedInCurrent.map(item => item.lineIdx);
            } else if (activeLineIndex !== -1) {
                targetIndices = [activeLineIndex];
            }

            if (targetIndices.length === 0) {
                alert("è¯·å…ˆç‚¹å‡»é€‰ä¸­è¯‘æ–‡ä¸­çš„æŸä¸€è¡Œï¼ˆæˆ–ä½¿ç”¨ Shift å¤šé€‰ï¼‰å†æ‰§è¡Œæ‹†åˆ†ã€‚");
                return;
            }

            const transLines = (r.translation || "").split('ã€BRã€‘');
            targetIndices.sort((a, b) => b - a); // é™åºå¤„ç†ï¼Œé˜²æ­¢ç´¢å¼•åç§»

            targetIndices.forEach(idx => {
                const lineData = JSON.parse(JSON.stringify(r.lines[idx]));
                const textData = (r.texts && r.texts[idx]) ? r.texts[idx] : "";
                // ã€æ ¸å¿ƒä¿®æ”¹ã€‘ï¼šå¦‚æœæ²¡ç¿»è¯‘ï¼Œç›´æ¥ç»™ç©ºå­—ç¬¦ä¸²ï¼Œä¸è¡¥åŸæ–‡
                const transData = transLines[idx] || ""; 

                // ä»åŸå¤§æ¡†ä¸­å‰”é™¤
                r.lines.splice(idx, 1);
                if (r.texts) r.texts.splice(idx, 1);
                transLines.splice(idx, 1);

                // åˆ›å»ºç‹¬ç«‹æ–°æ¡†
                const newR = {
                    ...JSON.parse(JSON.stringify(r)),
                    lines: [lineData],
                    texts: [textData],
                    translation: transData, 
                    box: [] 
                };
                initRegionBox(newR);
                regions.push(newR);
            });

            if (r.lines.length > 0) {
                r.translation = transLines.join('ã€BRã€‘');
                initRegionBox(r);
                setActiveRegion(activeRegionIndex);
            } else {
                regions.splice(activeRegionIndex, 1);
                activeRegionIndex = -1;
                resetSidebar();
            }

            selectedItems = [];
            activeLineIndex = -1;
            draw();
        };

        replaceBtnRight.onclick = () => {
            const isBatch = matchedFiles.length > 0;
            const scope = isBatch ? `å…¨ä¹¦ (${matchedFiles.length}é¡µ)` : "å½“å‰é¡µ";
            
            if (!confirm(`ç¡®å®šè¦å¯¹ ${scope} çš„åŸæ–‡æ‰§è¡Œè‡ªåŠ¨æ›¿æ¢å—ï¼Ÿ\nè¯¥æ“ä½œä¼šæŒ‰å›ºå®šè§„åˆ™ä¿®æ­£æ ‡ç‚¹ã€‚`)) return;

            const count = applyOriginalTextReplacement();

            // æŒ‰é’®åé¦ˆ
            const oldText = replaceBtnRight.innerText;
            replaceBtnRight.innerText = "OK!";
            replaceBtnRight.classList.add('text-green-400', 'border-green-500');
            
            console.log(`æ›¿æ¢å®Œæˆï¼Œä¿®æ­£äº† ${count} å¤„æ–‡æœ¬å†…å®¹ã€‚`);

            setTimeout(() => {
                replaceBtnRight.innerText = oldText;
                replaceBtnRight.classList.remove('text-green-400', 'border-green-500');
            }, 1200);
        };

        // ç»‘å®šå³ä¾§è¾¹æ â€œåˆ â€æŒ‰é’®
        const deleteBtnRight = document.getElementById('deleteBtnRight');

        deleteBtnRight.onclick = () => {
            // åªæœ‰åœ¨é€‰ä¸­äº†åŒºåŸŸæˆ–å…·ä½“è¡Œæ—¶æ‰æ‰§è¡Œåˆ é™¤
            if (activeRegionIndex !== -1) {
                // è°ƒç”¨ä½ å·²ç»å®šä¹‰å¥½çš„åˆ é™¤å‡½æ•°
                deleteActiveLine();
                
                // è§†è§‰åé¦ˆï¼šæŒ‰é’®é—ªçº¢æç¤º
                deleteBtnRight.classList.add('bg-red-900');
                setTimeout(() => {
                    deleteBtnRight.classList.remove('bg-red-900');
                }, 200);
            } else {
                console.log("æœªé€‰ä¸­ä»»ä½•å†…å®¹ï¼Œæ— éœ€åˆ é™¤");
            }
        };


        editPropBtnRight.onclick = () => {
            // 1. æ£€æŸ¥æ˜¯å¦æœ‰é€‰ä¸­çš„åŒºåŸŸ
            if (activeRegionIndex === -1 || !regions[activeRegionIndex]) {
                return;
            }

            const r = regions[activeRegionIndex];

            // 2. åˆ‡æ¢æ¨ªç«–æ’å±æ€§
            // å¦‚æœå½“å‰æ˜¯ç«–æ’ ('v') åˆ™åˆ‡ä¸ºæ¨ªæ’ ('h')ï¼Œåä¹‹äº¦ç„¶
            r.direction = (r.direction === 'v') ? 'h' : 'v';

            // 3. è§†è§‰åé¦ˆï¼šæŒ‰é’®æ–‡å­—ä¸´æ—¶æ˜¾ç¤ºå½“å‰çŠ¶æ€
            const originalText = editPropBtnRight.innerText;
            editPropBtnRight.innerText = (r.direction === 'v' ? "ç«–" : "æ¨ª");
            editPropBtnRight.classList.add('text-blue-400', 'border-blue-500/50');

            // 4. åŒæ­¥æ›´æ–°ä¾§è¾¹æ çŠ¶æ€æ–‡å­— (å¦‚æœæœ‰ç›¸å…³æ˜¾ç¤º)
            if (sidebarStatus) {
                // å¯ä»¥åœ¨çŠ¶æ€æ æç¤ºå½“å‰æ¨¡å¼
                const dirText = r.direction === 'v' ? "ç«–æ’æ¨¡å¼" : "æ¨ªæ’æ¨¡å¼";
                console.log(`åŒºåŸŸ #${activeRegionIndex + 1} å·²åˆ‡æ¢ä¸º ${dirText}`);
            }

            // 5. æ¢å¤æŒ‰é’®æ ·å¼å¹¶é‡ç»˜
            setTimeout(() => {
                editPropBtnRight.innerText = originalText;
                editPropBtnRight.classList.remove('text-blue-400', 'border-blue-500/50');
            }, 800);

            draw(); // ç«‹å³é‡æ–°æ¸²æŸ“ç”»å¸ƒä¸Šçš„æ–‡å­—æ’ç‰ˆ
        };

        /**
        * æ¸…æ´—è¯‘æ–‡ä¸­çš„å¤šä½™æ¢è¡Œç¬¦
        * 1. ç§»é™¤å¼€å¤´å’Œç»“å°¾çš„æ‰€æœ‰ ã€BRã€‘
        * 2. (å¯é€‰) å°†è¿ç»­å¤šä¸ª ã€BRã€‘ åˆå¹¶ä¸ºä¸€ä¸ª
        */
        function cleanTranslationText(text) {
            if (!text) return "";
            return text
                .replace(/^(ã€BRã€‘)+|(ã€BRã€‘)+$/g, '') // ç§»é™¤å¼€å¤´å’Œç»“å°¾çš„æ¢è¡Œç¬¦
                .replace(/(ã€BRã€‘){2,}/g, 'ã€BRã€‘');   // å°†è¿ç»­é‡å¤çš„æ¢è¡Œåˆå¹¶ä¸ºä¸€ä¸ª (æ ¹æ®éœ€æ±‚å¯é€‰)
        }

        // --- Rich Text Parser ---
        function parseRichText(text) {
            if (!text) return [{ text: "", style: {} }];
            const parts = text.split(/(\[\/?[a-z]+(?:=[^\]]*)?\])/i);
            const result = [];
            // åˆå§‹åŒ– styleStack
            const styleStack = [{ 
                bold: false, italic: false, tcy: false, dot: false, 
                scale: 1.0, font: null, ruby: null, rotation: 0,
                kerning: 0, offX: 0, offY: 0, vShear: 0,
                mirror: false,  // æ°´å¹³ç¿»è½¬
                mirrorV: false  // æ–°å¢ï¼šç«–å‘ç¿»è½¬
            }];

            parts.forEach(part => {
                if (!part) return;

                const tagMatch = part.match(/^\[(\/?)([a-z]+)(?:=([^\]]*))?\]$/i);
                if (tagMatch) {
                    const isClose = tagMatch[1] === '/';
                    const tagName = tagMatch[2].toLowerCase();
                    const param = tagMatch[3];

                    if (!isClose) {
                        const currentStyle = {...styleStack[styleStack.length - 1]};
                        if (tagName === 'b') currentStyle.bold = true;
                        else if (tagName === 'i') { if (param) { const angle = parseFloat(param); currentStyle.italic = isNaN(angle) ? true : angle; } else currentStyle.italic = true; }
                        else if (tagName === 't') currentStyle.tcy = true;
                        else if (tagName === 'd') currentStyle.dot = true;
                        else if (tagName === 's' && param) currentStyle.scale = parseFloat(param) || 1.0;
                        else if (tagName === 'f' && param) currentStyle.font = param;
                        else if (tagName === 'r' && param) currentStyle.ruby = param;
                        else if (tagName === 'rot' && param) currentStyle.rotation = parseFloat(param) || 0;
                        else if (tagName === 'k' && param) currentStyle.kerning = parseFloat(param) || 0;
                        else if (tagName === 'x' && param) currentStyle.offX = parseFloat(param) || 0;
                        else if (tagName === 'y' && param) currentStyle.offY = parseFloat(param) || 0;
                        // [æ–°å¢] å‚ç›´åˆ‡å˜è§£æ
                        else if (tagName === 'v' && param) currentStyle.vShear = parseFloat(param) || 0;
                        else if (tagName === 'm') currentStyle.mirror = true;
                        else if (tagName === 'mv') currentStyle.mirrorV = true; // å¤„ç† [mv] æ ‡ç­¾
                        styleStack.push(currentStyle);
                    } else { if (styleStack.length > 1) styleStack.pop(); }
                } else {
                    const currentStyle = styleStack[styleStack.length - 1];
                    result.push({ text: part, style: {...currentStyle} });
                }
            });
            return result;
        }

        // --- Editor Toolbar Helper ---
        window.insertTag = function(tag) {
            const textarea = document.getElementById('transEditArea');
            const start = textarea.selectionStart; const end = textarea.selectionEnd; const text = textarea.value;
            const selection = text.substring(start, end);
            const replacement = `[${tag}]${selection}[/${tag}]`;
            textarea.value = text.substring(0, start) + replacement + text.substring(end);

            // ã€æ–°å¢ã€‘æ‰‹åŠ¨è§¦å‘ input äº‹ä»¶ï¼Œè®©ç€é‡å·ç­‰ç«‹å³æ˜¾ç¤º
            textarea.dispatchEvent(new Event('input'));

            textarea.focus();
            textarea.selectionStart = start + replacement.length; textarea.selectionEnd = start + replacement.length;
        };

        // 1. ä¿®æ”¹æ’å…¥å‡½æ•°ï¼šå–æ¶ˆå¼¹çª—ï¼Œç›´æ¥æ’å…¥å¹¶è§¦å‘å³æ—¶é¢„è§ˆ
        window.insertTagWithParam = function(tag, promptMsg, defaultVal) {
            const textarea = document.getElementById('transEditArea');
            const start = textarea.selectionStart; const end = textarea.selectionEnd; const text = textarea.value;
            const selection = text.substring(start, end);
            
            const replacement = `[${tag}=${defaultVal}]${selection}[/${tag}]`;
            textarea.value = text.substring(0, start) + replacement + text.substring(end);
            textarea.focus();
            
            // è‡ªåŠ¨é€‰ä¸­æ•°å€¼éƒ¨åˆ†ï¼Œæ–¹ä¾¿ç”¨æˆ·ç›´æ¥æ”¹æ•°
            const newStart = start + tag.length + 2; 
            textarea.setSelectionRange(newStart, newStart + defaultVal.toString().length);
            
            // ã€å…³é”®ã€‘æ‰‹åŠ¨è§¦å‘ input äº‹ä»¶ï¼Œè®©ç”»é¢å®æ—¶å˜åŒ–
            textarea.dispatchEvent(new Event('input'));
        };
        window.insertTagWithOptionalParam = window.insertTagWithParam;

        // 2. ç»‘å®šå³æ—¶ç›‘å¬å™¨ï¼ˆå»ºè®®æ”¾åœ¨è„šæœ¬æœ«å°¾ resetSidebar ä¹‹å‰ï¼‰
        document.getElementById('transEditArea').addEventListener('input', (e) => {
            if (activeRegionIndex !== -1 && regions[activeRegionIndex]) {
                // å®æ—¶åŒæ­¥æ•°æ®
                regions[activeRegionIndex].translation = e.target.value.replace(/\n/g, 'ã€BRã€‘');
                // ç«‹å³é‡ç»˜
                draw();
            }
        });

        window.insertTagWithOptionalParam = function(tag, promptMsg, defaultVal) {
            // é€»è¾‘åŒä¸Šï¼Œç›´æ¥æ’å…¥
            const textarea = document.getElementById('transEditArea');
            const start = textarea.selectionStart; 
            const end = textarea.selectionEnd; 
            const text = textarea.value;
            const selection = text.substring(start, end);
            
            const replacement = `[${tag}=${defaultVal}]${selection}[/${tag}]`;
            
            textarea.value = text.substring(0, start) + replacement + text.substring(end);
            textarea.focus();
            
            const newStart = start + tag.length + 2;
            textarea.setSelectionRange(newStart, newStart + defaultVal.toString().length);
        };

        window.clearTags = function() {
            const textarea = document.getElementById('transEditArea');
            textarea.value = textarea.value.replace(/\[\/?[a-z]+(?:=[^\]]*)?\]/gi, "");

            // ã€æ–°å¢ã€‘æ‰‹åŠ¨è§¦å‘ input äº‹ä»¶ï¼Œè®©ç”»é¢ç«‹å³å˜å›çº¯æ–‡æœ¬
            textarea.dispatchEvent(new Event('input'));
            
            textarea.focus();
        }

        // --- Standard Init Logic ---
        jsonInput.addEventListener('change', handleJsonUpload);
        imageInput.addEventListener('change', handleImageUpload);
        fontFileInput.addEventListener('change', handleFontFileUpload);
        mainCanvas.addEventListener('mousedown', onMouseDown);
        mainCanvas.addEventListener('mousemove', onMouseMove);
        mainCanvas.addEventListener('mouseup', onMouseUp);
        window.addEventListener('resize', resizeCanvas);
        // ç»‘å®šæ»šè½®ç¼©æ”¾ (ç»‘å®šåˆ°å®¹å™¨ä¸Šï¼Œè€Œä¸æ˜¯ Canvas ä¸Šï¼Œä½“éªŒæ›´å¥½)
        const container = document.getElementById('canvasContainer');
        container.addEventListener('wheel', (e) => {
            e.preventDefault(); // é˜»æ­¢æµè§ˆå™¨é»˜è®¤æ»šåŠ¨

            const zoomIntensity = 0.1;
            const rect = container.getBoundingClientRect();
            
            // é¼ æ ‡ç›¸å¯¹äºå®¹å™¨çš„ä½ç½®
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // è®¡ç®—ç¼©æ”¾å‰çš„é¼ æ ‡åœ¨ç”»å¸ƒä¸Šçš„ä½ç½®
            const wheel = e.deltaY < 0 ? 1 : -1;
            const zoom = Math.exp(wheel * zoomIntensity);
            
            // é™åˆ¶ç¼©æ”¾èŒƒå›´ (0.1å€ åˆ° 10å€)
            const newScale = Math.max(0.1, Math.min(10, viewState.scale * zoom));
            
            // è®¡ç®—æ–°çš„åç§»é‡ï¼Œä½¿å¾—é¼ æ ‡æŒ‡å‘çš„ç‚¹ä½ç½®ä¸å˜ (Zoom towards mouse)
            viewState.x = mouseX - (mouseX - viewState.x) * (newScale / viewState.scale);
            viewState.y = mouseY - (mouseY - viewState.y) * (newScale / viewState.scale);
            viewState.scale = newScale;

            updateCanvasTransform();
        }, { passive: false });

        const autoTcyCb = document.getElementById('autoTcyCb');
        autoTcyCb.addEventListener('change', (e) => {
            activeAutoTcy = e.target.checked;
            draw(); // ç«‹å³é‡ç»˜
        });

        // è¾…åŠ©å‡½æ•°ï¼šåº”ç”¨ CSS å˜æ¢
        function updateCanvasTransform() {
            mainCanvas.style.transform = `translate(${viewState.x}px, ${viewState.y}px) scale(${viewState.scale})`;
        }

        fontSelect.addEventListener('change', (e) => {
            if(e.target.value === 'custom') { 
                customFontInput.classList.remove('hidden'); 
                customFontInput.focus(); 
            } else { 
                customFontInput.classList.add('hidden'); 
                
                // [ä¿®æ”¹] é€‰ä¸­æ¡†æ—¶åªæ”¹å½“å‰æ¡†ï¼Œå¦åˆ™æ”¹å…¨å±€
                const val = e.target.value;
                if (activeRegionIndex !== -1 && regions[activeRegionIndex]) {
                    regions[activeRegionIndex].fontFamily = val;
                } else {
                    activeFontFamily = val; 
                }
                draw(); 
            }
        });
        customFontInput.addEventListener('input', (e) => { 
            const val = `"${e.target.value}", sans-serif`;
            
            // [ä¿®æ”¹] åŒæ ·é€»è¾‘åº”ç”¨äºè‡ªå®šä¹‰å­—ä½“è¾“å…¥
            if (activeRegionIndex !== -1 && regions[activeRegionIndex]) {
                regions[activeRegionIndex].fontFamily = val;
            } else {
                activeFontFamily = val;
            }
            draw(); 
        });
        
        textAlignSelect.addEventListener('change', (e) => {
            const val = e.target.value;
            if (activeRegionIndex !== -1 && regions[activeRegionIndex]) { regions[activeRegionIndex].textAlign = val; draw(); } 
            else { activeTextAlign = val; }
        });

        btnForceAlign.addEventListener('click', () => {
            const currentAlign = textAlignSelect.value;
            pendingGlobalValue = currentAlign; pendingGlobalType = 'align';
            const alignName = textAlignSelect.options[textAlignSelect.selectedIndex].text;
            confirmMessage.innerHTML = `æ‚¨æ­£åœ¨æ‰§è¡Œ<b class="text-red-400">å¼ºåˆ¶é‡ç½®</b>æ“ä½œã€‚<br>æ˜¯å¦å°†å½“å‰çš„ <b class="text-yellow-400">[${alignName}]</b> åº”ç”¨åˆ°é¡µé¢ä¸Šçš„<b class="text-yellow-400">æ‰€æœ‰</b>æ–‡æœ¬æ¡†ï¼Ÿ<br><span class="text-xs text-gray-400">(è¿™å°†è¦†ç›–æ‰€æœ‰æ‰‹åŠ¨ä¿®æ”¹è¿‡çš„ä¸ªåˆ«æ’ç‰ˆ)</span>`;
            confirmModal.style.display = 'flex';
        });

        // 1. ç¡®å®šå…¨éƒ¨åº”ç”¨ï¼šåŒæ—¶æ›´æ–°å…¨å±€å˜é‡å’Œæ‰€æœ‰ç°æœ‰æ–¹æ¡†
        btnConfirmYes.addEventListener('click', () => {
            if (pendingGlobalValue && pendingGlobalType) {
                // éå†æ‰€æœ‰æ¡†è¿›è¡Œè¦†ç›–
                regions.forEach(r => {
                    if (pendingGlobalType === 'fill') r.parsedColor = pendingGlobalValue;
                    else if (pendingGlobalType === 'stroke') r.strokeColor = pendingGlobalValue;
                    else if (pendingGlobalType === 'align') r.textAlign = pendingGlobalValue;
                });

                // åŒæ­¥æ›´æ–°å…¨å±€é»˜è®¤å€¼ï¼Œç¡®ä¿åç»­æ–°å»ºçš„æ¡†ä¹Ÿä½¿ç”¨æ­¤å±æ€§
                if (pendingGlobalType === 'fill') activeTextColor = pendingGlobalValue;
                else if (pendingGlobalType === 'stroke') activeStrokeColor = pendingGlobalValue;
                else if (pendingGlobalType === 'align') {
                    activeTextAlign = pendingGlobalValue;
                    textAlignSelect.value = pendingGlobalValue; // åŒæ­¥é¡¶æ ä¸‹æ‹‰æ¡†çŠ¶æ€
                }

                draw(); // ç«‹å³é‡ç»˜
            }
            confirmModal.style.display = 'none';
            pendingGlobalValue = null; // æ¸…ç©ºæš‚å­˜
            pendingGlobalType = null;
        });

        // 2. å–æ¶ˆï¼šä¸åšä»»ä½•å¤„ç†ï¼Œç›´æ¥å…³é—­å¼¹çª—
        btnConfirmNo.addEventListener('click', () => {
            // é€»è¾‘å˜åŠ¨ï¼šä¸å†ä¿®æ”¹ä»»ä½• active å˜é‡ï¼Œç›´æ¥é€€å‡º
            confirmModal.style.display = 'none';
            
            // å¦‚æœæ˜¯æ”¹å¯¹é½æ–¹å¼ä¸­é€”å–æ¶ˆï¼ŒæŠŠä¸‹æ‹‰æ¡†çš„å€¼è¿˜åŸå›å»
            if (pendingGlobalType === 'align') {
                textAlignSelect.value = activeTextAlign;
            }
            
            pendingGlobalValue = null;
            pendingGlobalType = null;
        });

        strokeWidthInput.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            if (!isNaN(val) && val >= 0) {
                if (activeRegionIndex !== -1 && regions[activeRegionIndex]) {
                    // åœºæ™¯Aï¼šé€‰ä¸­äº†æŸä¸ªæ¡† -> åªæ”¹å½“å‰è¿™ä¸€ä¸ª
                    regions[activeRegionIndex].strokeWidthRatio = val;
                } else {
                    // åœºæ™¯Bï¼šæ²¡é€‰ä¸­æ¡† -> ç›´æ¥ä¿®æ”¹å…¨å±€é»˜è®¤å€¼ + æš´åŠ›ä¿®æ”¹é¡µé¢ä¸Šæ‰€æœ‰æ¡†
                    activeStrokeWidth = val;
                    regions.forEach(r => r.strokeWidthRatio = val);
                }
                // æ— è®ºå“ªç§æƒ…å†µï¼Œéƒ½ç«‹å³é‡ç»˜
                draw();
            }
        });

        document.getElementById('strokeRound').addEventListener('change', draw);
        
        // [æ–°å¢] å¡«å­”å¼€å…³äº‹ä»¶
        fillHolesCb.addEventListener('change', (e) => {
            if (activeRegionIndex !== -1 && regions[activeRegionIndex]) {
                regions[activeRegionIndex].fill_holes = e.target.checked;
                draw();
            }
        });

        strokeEnableCb.addEventListener('change', (e) => { activeStrokeEnabled = e.target.checked; draw(); });
        fontSizeInput.addEventListener('input', (e) => { 
            const val = parseFloat(e.target.value); 
            if(!isNaN(val) && val > 0) { 
                updateActiveRegionProp('font_size', val); 
            }
        });
        lineSpacingInput.addEventListener('input', (e) => { const val = parseFloat(e.target.value); if(!isNaN(val)) updateActiveRegionProp('line_spacing', val); });
        letterSpacingInput.addEventListener('input', (e) => { const val = parseFloat(e.target.value); if(!isNaN(val)) updateActiveRegionProp('letter_spacing', val); });
        // æ‰¾åˆ°ç¬¬ 829 è¡Œé™„è¿‘çš„ç›‘å¬å™¨ç»‘å®šï¼Œæ”¹ä¸ºå¦‚ä¸‹å¸¦åˆ¤æ–­çš„å†™æ³•ï¼š
        if (showBlocksCb) showBlocksCb.addEventListener('change', (e) => { showBlocks = e.target.checked; draw(); });
        if (showLinesCb) showLinesCb.addEventListener('change', (e) => { showLines = e.target.checked; draw(); });
        if (showTextCb) showTextCb.addEventListener('change', (e) => { showText = e.target.checked; draw(); });
        btnTrans.addEventListener('click', () => { displayMode = 'translation'; toggleModeBtns(); draw(); });
        btnOriginal.addEventListener('click', () => { displayMode = 'original'; toggleModeBtns(); draw(); });
        // --- çº¦ 821 è¡Œï¼šåˆ é™¤æˆ–æ³¨é‡Šæ‰ä¸‹é¢è¿™ä¸€è¡Œ ---
        // btnExport.addEventListener('click', exportImage);

        function updateColorSwatches() {
            let fill, stroke, sWidth;
            if (activeRegionIndex !== -1 && regions[activeRegionIndex]) {
                fill = colorToHex(regions[activeRegionIndex].parsedColor || activeTextColor);
                stroke = colorToHex(regions[activeRegionIndex].strokeColor || activeStrokeColor);
                sWidth = (regions[activeRegionIndex].strokeWidthRatio !== undefined) ? regions[activeRegionIndex].strokeWidthRatio : activeStrokeWidth;
            } else {
                fill = activeTextColor;
                stroke = activeStrokeColor;
                sWidth = activeStrokeWidth;
            }
            btnFillColor.style.backgroundColor = fill;
            btnStrokeColor.style.backgroundColor = stroke;
            strokeWidthInput.value = sWidth;
        }

        async function handleFontFileUpload(e) {
            const file = e.target.files[0]; if (!file) return;
            loadingMask.style.display = 'flex';
            try {
                const buffer = await file.arrayBuffer();
                const fontName = `MyFont_${loadedCustomFonts.length + 1}`;
                const fontFace = new FontFace(fontName, buffer);
                await fontFace.load(); document.fonts.add(fontFace);
                const option = document.createElement('option'); option.value = `"${fontName}", sans-serif`; option.text = `ğŸ“‚ ${file.name}`;
                fontSelect.add(option, 1); fontSelect.value = option.value; activeFontFamily = option.value;
                loadedCustomFonts.push(fontName); customFontInput.classList.add('hidden'); draw();
            } catch (err) { alert(`åŠ è½½å¤±è´¥ï¼š${err.message}`); } 
            finally { loadingMask.style.display = 'none'; e.target.value = ''; }
        }

        function handleJsonUpload(e) {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                let jsonStr = event.target.result.replace(/"mask_raw"\s*:\s*}/g, '"mask_raw": null }');
                try {
                    const raw = JSON.parse(jsonStr);
                    const data = raw.regions ? raw : raw[Object.keys(raw)[0]];
                    regions = data.regions || [];
                    regions.forEach(r => {
                        // ... (å‰é¢çš„å±æ€§åˆå§‹åŒ–ä»£ç ä¿æŒä¸å˜) ...
                        if (r.direction === 'v') r.line_spacing = 1.2; else r.line_spacing = 1.2;
                        if (r.fg_colors) r.parsedColor = parseColor(r.fg_colors);

                        // --- [æ–°å¢] åŠ è½½æ—¶è‡ªåŠ¨æ£€æµ‹ç™½è‰²å¹¶åŠ æè¾¹ ---
                        if (r.parsedColor) {
                            const hex = colorToHex(r.parsedColor);
                            if (isNearWhite(hex)) {
                                // å¦‚æœè¯¥åŒºåŸŸæœ¬èº«æ²¡æœ‰è®¾ç½®æè¾¹é¢œè‰²ï¼Œæˆ–è€…æè¾¹æ˜¯é€æ˜çš„
                                if (!r.strokeColor || r.strokeColor === 'none') {
                                    r.strokeColor = "#000000"; // è‡ªåŠ¨é»‘è¾¹
                                    // å¦‚æœæ²¡æœ‰æè¾¹ç²—ç»†ï¼Œç»™ä¸€ä¸ªé»˜è®¤å€¼ 0.2
                                    if (r.strokeWidthRatio === undefined || r.strokeWidthRatio === 0) {
                                        r.strokeWidthRatio = 0.2;
                                    }
                                }
                            }
                        }
                        
                        if (!r.strokeColor) r.strokeColor = null; 
                        if (typeof r.default_stroke_width !== 'undefined') r.strokeWidthRatio = r.default_stroke_width;
                        if (typeof r.letter_spacing === 'undefined') r.letter_spacing = 0;
                        if (r.translation) {
                            // ã€æ–°å¢ã€‘è‡ªåŠ¨æ¸…æ´—è¯‘æ–‡
                            r.translation = cleanTranslationText(r.translation);
                        }
                        restoreLinesFromCenter(r); // è¿˜åŸåæ ‡
                        initRegionBox(r); // è®¡ç®—åŒ…å›´ç›’
                    });

                    // âŒ åˆ é™¤è¿™ä¸€è¡Œï¼š renderSidebar(); 
                    // âŒ åˆ é™¤è¿™ä¸€è¡Œï¼š scrollToSidebar(...);
                    
                    // ä¿æŒè¿™ä¸€è¡Œï¼š
                    if(currentImage) draw();
                    
                    // [æ¨èæ–°å¢] åŠ è½½å®Œ JSON åï¼Œè‡ªåŠ¨é€‰ä¸­ç¬¬ä¸€ä¸ªæ¡†ï¼Œè®©ç”¨æˆ·çŸ¥é“åŠ è½½æˆåŠŸäº†
                    if(regions.length > 0) setActiveRegion(0);

                } catch (err) { alert("JSON è§£æå¤±è´¥: " + err.message); console.error(err); }
            };
            reader.readAsText(file);
        }

        function initRegionBox(region) {
            if (!region.lines || region.lines.length === 0) { region.box = [0,0,0,0]; region.angle = 0; return; }
            let angleDeg = 0;
            if (typeof region.angle === 'number') angleDeg = region.angle;
            else {
                let totalVecX = 0, totalVecY = 0;
                region.lines.forEach(poly => {
                    if (poly.length >= 4) {
                        const p0=poly[0], p1=poly[1], p2=poly[2], p3=poly[3];
                        totalVecX += (p1[0]-p0[0]) + (p2[0]-p3[0]); totalVecY += (p1[1]-p0[1]) + (p2[1]-p3[1]);
                    }
                });
                let angleRad = Math.atan2(totalVecY, totalVecX);
                angleDeg = angleRad * 180 / Math.PI;
            }
            if (angleDeg > 90) angleDeg -= 180; if (angleDeg < -90) angleDeg += 180;
            region.angle = angleDeg; 
            calculateBoxFromLines(region);
        }

        function calculateBoxFromLines(region) {
            let points = [];
            region.lines.forEach(l => l.forEach(p => points.push({x:p[0], y:p[1]})));
            if(points.length === 0) return;
            let cx = 0, cy = 0; points.forEach(p => { cx+=p.x; cy+=p.y; }); cx /= points.length; cy /= points.length;
            const center = {x:cx, y:cy};
            const rad = -region.angle * Math.PI / 180; const cos = Math.cos(rad), sin = Math.sin(rad);
            let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
            points.forEach(p => {
                const dx = p.x - center.x; const dy = p.y - center.y;
                const rx = dx*cos - dy*sin + center.x; const ry = dx*sin + dy*cos + center.y;
                minX = Math.min(minX, rx); maxX = Math.max(maxX, rx); minY = Math.min(minY, ry); maxY = Math.max(maxY, ry);
            });
            const width = maxX - minX; const height = maxY - minY;
            const midX = minX + width/2; const midY = minY + height/2;
            const revRad = region.angle * Math.PI / 180; const revCos = Math.cos(revRad), revSin = Math.sin(revRad);
            const dx = midX - center.x; const dy = midY - center.y;
            const finalCx = dx*revCos - dy*revSin + center.x; const finalCy = dx*revSin + dy*revCos + center.y;
            region.box = [finalCx - width/2, finalCy - height/2, finalCx + width/2, finalCy + height/2];
        }

        function getRegionHandles(region) {
            if (!region.box) return [];
            const [x1,y1,x2,y2] = region.box; 
            const w = x2-x1, h = y2-y1;
            const cx = x1+w/2, cy = y1+h/2;
            const rad = region.angle * Math.PI / 180;
            const cos = Math.cos(rad), sin = Math.sin(rad);
            
            // åŸºç¡€å˜æ¢å‡½æ•°
            const transform = (ox, oy) => ({ x: ox*cos - oy*sin + cx, y: ox*sin + oy*cos + cy });

            // æ¢å¤åŸå§‹çš„å…‰æ ‡æ˜ å°„
            return [
                { ...transform(-w/2, -h/2), type: 'scale', index: 0, cursor: 'nwse-resize' }, 
                { ...transform(w/2, -h/2),  type: 'scale', index: 1, cursor: 'nesw-resize' },
                { ...transform(w/2, h/2),   type: 'scale', index: 2, cursor: 'nwse-resize' },
                { ...transform(-w/2, h/2),  type: 'scale', index: 3, cursor: 'nesw-resize' },
                { ...transform(0, -h/2),    type: 'scale', index: 4, cursor: 'ns-resize' },
                { ...transform(w/2, 0),     type: 'scale', index: 5, cursor: 'ew-resize' },
                { ...transform(0, h/2),     type: 'scale', index: 6, cursor: 'ns-resize' },
                { ...transform(-w/2, 0),    type: 'scale', index: 7, cursor: 'ew-resize' },
                { ...transform(0, -h/2 - ROTATE_HANDLE_OFFSET), type: 'rotate', cursor: 'grab' }
            ];
        }
        /**
         * ä¸ºå•ä¸ªå°æ¡†ç”Ÿæˆæ‰‹æŸ„ï¼ˆåŒ…å«è¾¹ä¸­ç‚¹å’Œæ—‹è½¬ç‚¹ï¼‰
         */
        function getLineHandles(line) {
            const handles = [];
            // 1. è¾¹ä¸­ç‚¹æ‰‹æŸ„ä¿æŒä¸å˜
            for (let i = 0; i < 4; i++) {
                const p1 = line[i], p2 = line[(i + 1) % 4];
                handles.push({ 
                    x: (p1[0] + p2[0]) / 2, 
                    y: (p1[1] + p2[1]) / 2, 
                    type: 'move-edge', 
                    index: i,
                    cursor: i % 2 === 0 ? 'ns-resize' : 'ew-resize' 
                });
            }
            // 2. æ—‹è½¬æ‰‹æŸ„
            const p0 = line[0], p1 = line[1];
            const topMid = { x: (p0[0] + p1[0]) / 2, y: (p0[1] + p1[1]) / 2 };
            const edgeVec = { x: p1[0] - p0[0], y: p1[1] - p0[1] };
            let normalVec = { x: edgeVec.y, y: -edgeVec.x }; // æŒ‡å‘æ¡†å¤–

            const len = Math.hypot(normalVec.x, normalVec.y);
            if (len > 0) { 
                const offset = 30 / viewState.scale;
                handles.push({
                    x: topMid.x + (normalVec.x / len) * offset,
                    y: topMid.y + (normalVec.y / len) * offset,
                    anchorX: topMid.x, // ã€æ–°å¢ã€‘è¿æ¥çº¿èµ·ç‚¹ X
                    anchorY: topMid.y, // ã€æ–°å¢ã€‘è¿æ¥çº¿èµ·ç‚¹ Y
                    type: 'rotate-line',
                    cursor: 'grab'
                });
            }
            return handles;
        }

        function onMouseDown(e) {
            const pos = getMousePos(e); 

            if (isDrawingMode) {
                drawStartPos = pos;
                tempDrawRect = { x: pos.x, y: pos.y, w: 0, h: 0 };
                return; 
            }

            // --- 1. æ‰‹æŸ„æ“ä½œä¼˜å…ˆçº§æœ€é«˜ ---
            if (activeRegionIndex !== -1) {
                const region = regions[activeRegionIndex]; // å¿…é¡»å…ˆå®šä¹‰ region
                
                // ã€è¯‘æ–‡æ¨¡å¼æ‰‹æŸ„æ£€æµ‹ã€‘
                if (displayMode === 'translation') {
                    const handles = getRegionHandles(region);
                    for(let h of handles) {
                        const hitThreshold = 20 / viewState.scale; // ç»Ÿä¸€ 20px åˆ¤å®šåŒº
                        
                        if (Math.hypot(pos.x - h.x, pos.y - h.y) < hitThreshold) {
                            transformState.dragging = true; 
                            transformState.action = h.type; 
                            transformState.handleIndex = h.index; 
                            transformState.startMouse = pos; 
                            transformState.startBox = [...region.box];
                            transformState.startBoxAngle = region.angle || 0; // ç»Ÿä¸€å˜é‡å

                            const [x1, y1, x2, y2] = transformState.startBox;
                            const cx = x1 + (x2 - x1) / 2;
                            const cy = y1 + (y2 - y1) / 2;

                            if (h.type === 'rotate') {
                                transformState.center = { x: cx, y: cy };
                                transformState.startMouseAngle = Math.atan2(pos.y - cy, pos.x - cx);
                                return; 
                            }

                            // ç¼©æ”¾é”šç‚¹é€»è¾‘
                            const rad = transformState.startBoxAngle * Math.PI / 180;
                            const cos = Math.cos(rad), sin = Math.sin(rad);
                            let ox, oy, fx, fy;
                            const w2 = (x2 - x1) / 2, h2 = (y2 - y1) / 2;
                            switch(h.index) {
                                case 0: ox = w2;  oy = h2;  fx = -1; fy = -1; break;
                                case 1: ox = -w2; oy = h2;  fx = 1;  fy = -1; break;
                                case 2: ox = -w2; oy = -h2; fx = 1;  fy = 1;  break;
                                case 3: ox = w2;  oy = -h2; fx = -1; fy = 1;  break;
                                case 4: ox = 0;   oy = h2;  fx = 0;  fy = -1; break;
                                case 5: ox = -w2; oy = 0;   fx = 1;  fy = 0;  break;
                                case 6: ox = 0;   oy = -h2; fx = 0;  fy = 1;  break;
                                case 7: ox = w2;  oy = 0;   fx = -1; fy = 0;  break;
                            }
                            transformState.anchor = { x: ox * cos - oy * sin + cx, y: ox * sin + oy * cos + cy };
                            transformState.factor = { x: fx, y: fy };
                            return; 
                        }
                    }
                }
                // ã€åŸæ–‡æ¨¡å¼å°æ¡†æ‰‹æŸ„æ£€æµ‹ã€‘
                else if (activeLineIndex !== -1 && region.lines[activeLineIndex]) {
                    const lineIdx = activeLineIndex; 
                    const lineHandles = getLineHandles(region.lines[lineIdx]);
                    for (let h of lineHandles) {
                        const hitThreshold = 15 / viewState.scale; // ç»Ÿä¸€ 15px åˆ¤å®šåŒº
                        if (Math.hypot(pos.x - h.x, pos.y - h.y) < hitThreshold) {
                            transformState.dragging = true; 
                            transformState.action = h.type; 
                            transformState.handleIndex = h.index; 
                            transformState.lineIndex = lineIdx;
                            transformState.startMouse = pos;
                            transformState.originalPoints = JSON.parse(JSON.stringify(region.lines[lineIdx]));
                            
                            // è®°å½•å°æ¡†ä¸­å¿ƒç”¨äºæ—‹è½¬
                            let lx = 0, ly = 0;
                            region.lines[lineIdx].forEach(p => { lx += p[0]; ly += p[1]; });
                            const lcx = lx / 4, lcy = ly / 4;
                            transformState.lineCenter = { x: lcx, y: lcy };
                            transformState.startMouseAngle = Math.atan2(pos.y - lcy, pos.x - lcx);
                            return;
                        }
                    }
                }
            }

            // --- 2. å‘½ä¸­æ£€æµ‹ (åŒºåŸŸä¸å•è¡Œ) ---
            const hit = findRegionAt(pos); 

            if (hit) {
                if (e.shiftKey) {
                    // å¤šé€‰é€»è¾‘... (ä¿æŒä½ åŸæœ‰çš„ä¸å˜)
                    isShiftMultiSelect = true; 
                    const existingIdx = selectedItems.findIndex(item => item.regionIdx === hit.regionIdx && item.lineIdx === hit.lineIdx);
                    if (existingIdx > -1) selectedItems.splice(existingIdx, 1); 
                    else selectedItems.push(hit);
                    activeRegionIndex = hit.regionIdx;
                    activeLineIndex = hit.lineIdx;
                } else {
                    isShiftMultiSelect = false; 
                    selectedItems = [hit]; 
                    activeRegionIndex = hit.regionIdx;
                    activeLineIndex = hit.lineIdx;
                    setActiveRegion(hit.regionIdx);

                    transformState.dragging = true;
                    transformState.startMouse = pos;

                    // ã€æ ¸å¿ƒä¿®å¤ã€‘ï¼šåŸæ–‡æ¨¡å¼ä¸‹ç‚¹ä¸­è¡Œæ‰ç§»åŠ¨å°æ¡†ï¼Œå¦åˆ™ä¸€å¾‹ç§»åŠ¨å¤§æ¡†
                    if (displayMode === 'original' && hit.lineIdx !== -1) {
                        transformState.action = 'move-line'; 
                        transformState.lineIndex = hit.lineIdx;
                        transformState.originalPoints = JSON.parse(JSON.stringify(regions[hit.regionIdx].lines[hit.lineIdx]));
                    } else {
                        transformState.action = 'move-region'; 
                        transformState.startBox = [...regions[hit.regionIdx].box];
                    }
                }
                draw(); 
                return;
            }

            // --- 3. ç©ºç™½å¤„å¤„ç† ---
            if (e.button === 0) {
                if (isSpacePressed || !hit) {
                    viewState.isPanning = true; 
                    viewState.startX = e.clientX; 
                    viewState.startY = e.clientY;
                    document.getElementById('canvasContainer').style.cursor = 'grabbing';
                    if (!hit) {
                        resetSidebar(); 
                        activeLineIndex = -1;
                        selectedItems = [];
                        isShiftMultiSelect = false;
                        draw();
                    }
                    return;
                }
            }
        }

function onMouseMove(e) {
            const pos = getMousePos(e);
            let cursor = 'default';

            if (isDrawingMode && drawStartPos) {
                tempDrawRect.w = pos.x - drawStartPos.x;
                tempDrawRect.h = pos.y - drawStartPos.y;
                draw(); return;
            }

            if (viewState.isPanning) {
                const dx = e.clientX - viewState.startX; const dy = e.clientY - viewState.startY;
                viewState.x += dx; viewState.y += dy;
                viewState.startX = e.clientX; viewState.startY = e.clientY;
                updateCanvasTransform(); return;
            }

            if (transformState.dragging && activeRegionIndex !== -1) {
                const region = regions[activeRegionIndex];
                
                // 1. ç§»åŠ¨å°æ¡†
                if (transformState.action === 'move-line') {
                    const line = region.lines[transformState.lineIndex];
                    const orig = transformState.originalPoints;
                    if (line && orig) { // å¢åŠ åˆ¤ç©ºé˜²æ­¢å´©æºƒ
                        const dx = pos.x - transformState.startMouse.x;
                        const dy = pos.y - transformState.startMouse.y;
                        for (let i = 0; i < 4; i++) {
                            line[i][0] = orig[i][0] + dx;
                            line[i][1] = orig[i][1] + dy;
                        }
                    }
                }
                // 2. ç§»åŠ¨å¤§æ¡†
                else if (transformState.action === 'move-region') {
                    const origBox = transformState.startBox;
                    const dx = pos.x - transformState.startMouse.x;
                    const dy = pos.y - transformState.startMouse.y;
                    region.box = [
                        origBox[0] + dx, origBox[1] + dy,
                        origBox[2] + dx, origBox[3] + dy
                    ];
                }
                // 3. å¢é‡æ—‹è½¬ (å¤§æ¡†)
                else if (transformState.action === 'rotate' && transformState.center) {
                    const curAngle = Math.atan2(pos.y - transformState.center.y, pos.x - transformState.center.x);
                    const deltaAngle = (curAngle - transformState.startMouseAngle) * 180 / Math.PI;
                    region.angle = transformState.startBoxAngle + deltaAngle; // ä½¿ç”¨ startBoxAngle
                }
                // 4. é”šç‚¹ç¼©æ”¾ (å¤§æ¡†)
                else if (transformState.action === 'scale') {
                    const anchor = transformState.anchor;
                    const factor = transformState.factor;
                    const dx = pos.x - anchor.x, dy = pos.y - anchor.y;
                    const rad = region.angle * Math.PI / 180;
                    const cos = Math.cos(rad), sin = Math.sin(rad);
                    const localDistX = dx * cos + dy * sin;
                    const localDistY = -dx * sin + dy * cos;

                    const [ox1, oy1, ox2, oy2] = transformState.startBox;
                    const oldW = ox2 - ox1, oldH = oy2 - oy1;
                    const newW = Math.max(5, factor.x !== 0 ? localDistX * factor.x : oldW);
                    const newH = Math.max(5, factor.y !== 0 ? localDistY * factor.y : oldH);

                    const offsetX = (newW / 2) * (-factor.x);
                    const offsetY = (newH / 2) * (-factor.y);
                    const newCx = anchor.x - (offsetX * cos - offsetY * sin);
                    const newCy = anchor.y - (offsetX * sin + offsetY * cos);

                    region.box = [newCx - newW/2, newCy - newH/2, newCx + newW/2, newCy + newH/2];
                }
                // 5. å°æ¡†è¾¹æ‹‰æ‹½
                else if (transformState.action === 'move-edge') {
                    const line = region.lines[transformState.lineIndex];
                    const orig = transformState.originalPoints;
                    const p1 = transformState.handleIndex, p2 = (p1 + 1) % 4;
                    const dx = pos.x - transformState.startMouse.x, dy = pos.y - transformState.startMouse.y;
                    const edgeVec = { x: orig[p2][0] - orig[p1][0], y: orig[p2][1] - orig[p1][1] };
                    let norm = { x: -edgeVec.y, y: edgeVec.x };
                    const len = Math.hypot(norm.x, norm.y); if (len > 0) { norm.x /= len; norm.y /= len; }
                    const proj = dx * norm.x + dy * norm.y;
                    line[p1] = [orig[p1][0] + proj * norm.x, orig[p1][1] + proj * norm.y];
                    line[p2] = [orig[p2][0] + proj * norm.x, orig[p2][1] + proj * norm.y];
                }
                // 6. å°æ¡†æ—‹è½¬
                else if (transformState.action === 'rotate-line') {
                    const line = region.lines[transformState.lineIndex];
                    const orig = transformState.originalPoints;
                    const center = transformState.lineCenter;
                    if (center && orig) {
                        const curAng = Math.atan2(pos.y - center.y, pos.x - center.x);
                        const dAng = curAng - transformState.startMouseAngle;
                        const cos = Math.cos(dAng), sin = Math.sin(dAng);
                        orig.forEach((p, idx) => {
                            const dx = p[0] - center.x, dy = p[1] - center.y;
                            line[idx] = [dx * cos - dy * sin + center.x, dx * sin + dy * cos + center.y];
                        });
                    }
                }
                draw(); return;
            }

            // é¼ æ ‡æ‰‹åŠ¿åŒæ­¥é€»è¾‘
            if (cursor === 'default' && activeRegionIndex !== -1) {
                const region = regions[activeRegionIndex];
                if (displayMode === 'translation') {
                    const handles = getRegionHandles(region);
                    for (let h of handles) {
                        if (Math.hypot(pos.x - h.x, pos.y - h.y) < 20 / viewState.scale) {
                            cursor = h.cursor || 'pointer'; break;
                        }
                    }
                } else if (region.lines && activeLineIndex !== -1) {
                    const lineHandles = getLineHandles(region.lines[activeLineIndex]);
                    for (let h of lineHandles) {
                        if (Math.hypot(pos.x - h.x, pos.y - h.y) < 15 / viewState.scale) {
                            cursor = h.cursor || 'pointer'; break;
                        }
                    }
                }
            }
            mainCanvas.style.cursor = cursor;
        }
        

        // 1. ç‚¹å‡»è‡ªå®šä¹‰æ–¹å— -> è§¦å‘åŸç”Ÿé€‰æ‹©å™¨
        btnFillColor.addEventListener('click', () => {
            // [å…³é”®ä¿®æ”¹] æ‰“å¼€å‰ï¼Œå…ˆè®°ä¸‹å½“å‰é€‰ä¸­çš„æ˜¯è°ï¼ˆæˆ–è€…æ˜¯ -1ï¼‰
            colorPickTargetIndex = activeRegionIndex; 

            // è®¾ç½®åˆå§‹å€¼
            let currentColor = (colorPickTargetIndex !== -1 && regions[colorPickTargetIndex]) ? 
                colorToHex(regions[colorPickTargetIndex].parsedColor || activeTextColor) : activeTextColor;
            nativeFillPicker.value = currentColor;
            nativeFillPicker.click(); 
        });

        btnStrokeColor.addEventListener('click', () => {
            // [å…³é”®ä¿®æ”¹] åŒæ ·è®°ä¸‹ç›®æ ‡
            colorPickTargetIndex = activeRegionIndex;

            let currentColor = (colorPickTargetIndex !== -1 && regions[colorPickTargetIndex]) ? 
                colorToHex(regions[colorPickTargetIndex].strokeColor || activeStrokeColor) : activeStrokeColor;
            nativeStrokePicker.value = currentColor;
            nativeStrokePicker.click(); 
        });

        const btnBlurColor = document.getElementById('btnBlurColor');

        // ç‚¹å‡»é¢„è§ˆæ–¹å—è§¦å‘é€‰æ‹©å™¨
        btnBlurColor.addEventListener('click', () => {
            colorPickTargetIndex = activeRegionIndex; // è®°å½•å½“å‰æ“ä½œçš„æ¡†
            let currentColor = (colorPickTargetIndex !== -1 && regions[colorPickTargetIndex]) ? 
                (regions[colorPickTargetIndex].blurColor || "#000000") : "#000000";
            nativeBlurPicker.value = colorToHex(currentColor);
            nativeBlurPicker.click();
        });

        // å¤„ç†é¢œè‰²å˜åŒ–
        nativeBlurPicker.addEventListener('input', (e) => {
            const color = e.target.value;
            btnBlurColor.style.backgroundColor = color;
            if (colorPickTargetIndex !== -1 && regions[colorPickTargetIndex]) {
                regions[colorPickTargetIndex].blurColor = color;
            }
            draw();
        });

        // 2. ç»‘å®šé€šç”¨å¤„ç†å‡½æ•°
        setupNativePicker(nativeFillPicker, 'fill');
        setupNativePicker(nativeStrokePicker, 'stroke');

        function setupNativePicker(picker, type) {
            picker.addEventListener('input', (e) => {
                const color = e.target.value;
                const isFill = type === 'fill';
                
                if (isFill) {
                    btnFillColor.style.backgroundColor = color;
                    // å¤„ç†åº”ç”¨å¯¹è±¡
                    if (colorPickTargetIndex !== -1 && regions[colorPickTargetIndex]) {
                        regions[colorPickTargetIndex].parsedColor = color;
                        
                        // --- ã€æ–°å¢é€»è¾‘ã€‘å¦‚æœæ˜¯ç™½è‰²ç³»ï¼Œè‡ªåŠ¨è®¾ç½®é»‘è‰²æè¾¹ ---
                        if (isNearWhite(color)) {
                            regions[colorPickTargetIndex].strokeColor = "#000000"; // è®¾ä¸ºé»‘è‰²
                            strokeEnableCb.checked = true; // è‡ªåŠ¨å‹¾é€‰å¼€å¯æè¾¹
                            btnStrokeColor.style.backgroundColor = "#000000";
                        }
                    } else {
                        activeTextColor = color;
                        if (isNearWhite(color)) {
                            activeStrokeColor = "#000000";
                            strokeEnableCb.checked = true;
                            btnStrokeColor.style.backgroundColor = "#000000";
                        }
                    }
                } else {
                    // æè¾¹é¢œè‰²ä¿®æ”¹é€»è¾‘ä¿æŒä¸å˜
                    btnStrokeColor.style.backgroundColor = color;
                    if (colorPickTargetIndex !== -1 && regions[colorPickTargetIndex]) {
                        regions[colorPickTargetIndex].strokeColor = color;
                    } else {
                        activeStrokeColor = color;
                    }
                }
                draw();
            });


            // [é˜¶æ®µB] æœ€ç»ˆç¡®è®¤ (changeäº‹ä»¶)
            picker.addEventListener('change', (e) => {
                const color = e.target.value;
                
                // [å…³é”®ä¿®æ”¹] åªæœ‰å½“â€œæ‰“å¼€å–è‰²å™¨æ—¶å°±æ²¡æœ‰é€‰ä¸­ä»»ä½•æ¡†â€çš„æƒ…å†µï¼Œæ‰é—®æ˜¯å¦åº”ç”¨å…¨å±€
                // å¦‚æœæ‰“å¼€æ—¶é€‰ä¸­äº†æ¡†ï¼Œå“ªæ€•ç°åœ¨å–æ¶ˆé€‰ä¸­äº†ï¼Œä¹Ÿä¸ä¼šå¼¹çª—ï¼Œè¿™ç¬¦åˆç”¨æˆ·ç›´è§‰
                if (colorPickTargetIndex === -1) {
                    pendingGlobalValue = color;
                    pendingGlobalType = type; 
                    
                    const typeName = type === 'fill' ? 'å¡«å……é¢œè‰²' : 'æè¾¹é¢œè‰²';
                    confirmMessage.innerHTML = `æ‚¨å·²ä¿®æ”¹é»˜è®¤${typeName}ã€‚<br>æ˜¯å¦å°†æ­¤é¢œè‰²åº”ç”¨åˆ°å½“å‰é¡µé¢çš„<b class="text-yellow-400">æ‰€æœ‰</b>æ–‡æœ¬æ¡†ï¼Ÿ`;
                    confirmModal.style.display = 'flex';
                }
                
                // [æ–°å¢] åªæœ‰åœ¨é’ˆå¯¹å•ä¸ªæ¡†ä¿®æ”¹ç»“æŸæ—¶ï¼Œä¸ºäº†é˜²æ­¢é¢œè‰²æ²¡åŒæ­¥ï¼ˆå› ä¸ºinputäº‹ä»¶å¯èƒ½æ²¡è¦†ç›–æœ€åä¸€ä¸‹ï¼‰ï¼Œä¿é™©èµ·è§å†ç”»ä¸€æ¬¡
                // å¹¶ä¸”å¦‚æœç”¨æˆ·æ˜¯åœ¨æ”¹å•ä¸ªæ¡†ï¼Œç»“æŸåå°±ä¸éœ€è¦é‡ç½® activeRegionIndexï¼Œä¿æŒåŸæ ·å³å¯
                if (colorPickTargetIndex !== -1) {
                    draw();
                }
            });
        }

        // [æ–°å¢] å­—é‡æ§åˆ¶ç›‘å¬
        
        fontWeightSelect.addEventListener('change', (e) => {
            const val = e.target.value;
            if (activeRegionIndex !== -1 && regions[activeRegionIndex]) {
                // åœºæ™¯Aï¼šé€‰ä¸­å•ä¸ªæ¡† -> åªæ”¹è¿™ä¸ª
                regions[activeRegionIndex].fontWeight = val;
            } else {
                // åœºæ™¯Bï¼šæœªé€‰ä¸­ -> æ”¹å…¨å±€é»˜è®¤ + æš´åŠ›åˆ·æ–°æ‰€æœ‰æ¡†
                activeFontWeight = val;
                regions.forEach(r => r.fontWeight = val);
            }
            draw();
        });


        function onMouseUp() {
            // ã€å…³é”®ä¿®æ”¹ç‚¹ã€‘ï¼šç»“æŸç»˜åˆ¶å¹¶è‡ªåŠ¨é€€å‡ºæ¨¡å¼
            if (isDrawingMode && drawStartPos && tempDrawRect) {
                if (Math.abs(tempDrawRect.w) > 5 && Math.abs(tempDrawRect.h) > 5) {
                    const x1 = Math.min(drawStartPos.x, drawStartPos.x + tempDrawRect.w);
                    const y1 = Math.min(drawStartPos.y, drawStartPos.y + tempDrawRect.h);
                    const x2 = Math.max(drawStartPos.x, drawStartPos.x + tempDrawRect.w);
                    const y2 = Math.max(drawStartPos.y, drawStartPos.y + tempDrawRect.h);

                    const newRegion = {
                        box: [x1, y1, x2, y2],
                        angle: 0,
                        direction: 'v',
                        translation: "æ–°åŒºåŸŸ",
                        texts: ["æ–°è¡Œ"],
                        font_size: 20,
                        line_spacing: 1.2,
                        parsedColor: activeTextColor,
                        strokeColor: activeStrokeColor,
                        strokeWidthRatio: activeStrokeWidth,
                        lines: [[ [x1,y1], [x2,y1], [x2,y2], [x1,y2] ]]
                    };

                    regions.push(newRegion);
                    setActiveRegion(regions.length - 1);
                }
                
                // --- æ ¸å¿ƒæ”¹åŠ¨ï¼šç”»å®Œç«‹åˆ»å…³é—­å¼€å…³å¹¶æ¢å¤ UI ---
                isDrawingMode = false; 
                const btn = document.getElementById('drawModeBtnRight');
                if (btn) {
                    btn.classList.remove('bg-yellow-600', 'text-white');
                }
                // æ¢å¤ç”»å¸ƒå…‰æ ‡ä¸ºé»˜è®¤ï¼ˆæŠ“æ‰‹ï¼‰
                document.getElementById('canvasContainer').style.cursor = 'grab';

                drawStartPos = null;
                tempDrawRect = null;
                draw();
                return;
            }

            // åŸæœ‰çš„å¹³ç§»/æ‹–æ‹½åœæ­¢é€»è¾‘
            viewState.isPanning = false;
            transformState.dragging = false;
            transformState.action = null;
            draw();
        }

        function draw() {
            if(!ctx) return;
            
            // 1. ç¡®å®šèƒŒæ™¯åº•å›¾ (åŸæ–‡æ¨¡å¼ vs è¯‘æ–‡/ä¿®å¤å›¾æ¨¡å¼)
            let bgImage = (displayMode === 'translation' && currentRepairImage) ? currentRepairImage : currentImage;
            if(!bgImage) return;

            ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height); 
            ctx.drawImage(bgImage, 0, 0);
            
            // --- ã€æ–°å¢ï¼šæ–‡å­—å±‚æ§åˆ¶ã€‘ ---
            // åªæœ‰åœ¨å¼€å¯â€œå­—â€å¼€å…³æ—¶ï¼Œæ‰æ¸²æŸ“å¤æ‚çš„è¯‘æ–‡æˆ–åŸæ–‡æ–‡æœ¬
            if (showText) {
                if(displayMode === 'translation') {
                    // ä¸¥æ ¼æŒ‰æ±‰å ¡åŒ…é¡ºåºç»˜åˆ¶ï¼šåº•å±‚å‘å…‰ -> ä¸­å±‚æè¾¹ -> é¡¶å±‚å¡«å……
                    regions.forEach(r => drawSmartTranslation(r, 'glow'));   
                    regions.forEach(r => drawSmartTranslation(r, 'stroke'));
                    regions.forEach(r => drawSmartTranslation(r, 'fill'));
                } else {
                    // åŸæ–‡æ¨¡å¼ä¸‹çš„ OCR æ–‡æœ¬é¢„è§ˆ
                    regions.forEach(r => drawOriginal(r));
                }
            }

            // 2. UI è£…é¥°ä¸äº¤äº’å±‚ (æ¡†çº¿ã€æ‰‹æŸ„)
            regions.forEach((r, i) => {
                const active = (i === activeRegionIndex);

                // 1. ã€æ ¸å¿ƒæ¢å¤ã€‘è®¡ç®—å½“å‰æ´»åŠ¨åŒºåŸŸçš„æœ€å€¼å­—å·ç´¢å¼•
                let minSizeIdx = -1, maxSizeIdx = -1;
                if (active && r.lines && r.lines.length > 1) {
                    let minS = Infinity, maxS = -Infinity;
                    const textSource = r.texts || (r.translation ? r.translation.split('ã€BRã€‘') : []);
                    const isV = r.direction === 'v';
                    
                    r.lines.forEach((line, lIdx) => {
                        const txt = textSource[lIdx] || "";
                        // ä½¿ç”¨ä½ çš„è‡ªåŠ¨å­—å·è®¡ç®—å‡½æ•°
                        const size = getSingleLineAutoFontSize(txt, line, isV);
                        if (size < minS) { minS = size; minSizeIdx = lIdx; }
                        if (size > maxS) { maxS = size; maxSizeIdx = lIdx; }
                    });
                }

                if (r.lines && (showLines || active)) {
                    r.lines.forEach((line, lIdx) => {
                        ctx.save();
                        
                        // --- [A. è¡Œæ¡†æ¸²æŸ“] éƒ¨åˆ† ---

                        // 1. åŸºç¡€æ ·å¼åˆå§‹åŒ–
                        let color = '#3b82f6'; // é»˜è®¤ï¼šä¸é€æ˜è“è‰²
                        let lineWidth = 1.5;

                        // 2. çŠ¶æ€åˆ¤å®š
                        // æ£€æŸ¥å½“å‰è¡Œæ˜¯å¦åœ¨é€‰ä¸­é˜Ÿåˆ—ä¸­
                        const selectOrder = selectedItems.findIndex(item => item.regionIdx === i && item.lineIdx === lIdx);
                        const isInSelection = selectOrder > -1;

                        /**
                         * ã€æ ¸å¿ƒä¿®æ”¹ã€‘åˆ¤å®šé€»è¾‘ï¼š
                         * åªæœ‰å½“ Shift æ¨¡å¼å¼€å¯ï¼Œä¸”å½“å‰è¡Œç¡®å®è¢«é€‰ä¸­æ—¶ï¼Œæ‰åˆ¤å®šä¸º MultiSelected (æ©™è‰²)
                         * è¿™æ ·å¯ä»¥é¿å…åœ¨é Shift æ¨¡å¼ä¸‹ï¼Œå•çº¯çš„æ•°ç»„æ®‹ç•™å¯¼è‡´é”™è¯¯çš„é¢œè‰²æ˜¾ç¤º
                         */
                        const isMultiSelected = isShiftMultiSelect && isInSelection;

                        // å•é€‰æ¿€æ´»åˆ¤å®šï¼ˆé€šå¸¸ç”¨äºç¼–è¾‘çŠ¶æ€ï¼‰
                        const isSingleActive = (active && lIdx === activeLineIndex);

                        // 3. æ ·å¼ä¼˜å…ˆçº§åº”ç”¨ (å¤šé€‰æ©™ > å•é€‰çº¢ > æœ€å€¼é«˜äº®)
                        if (isMultiSelected) {
                            color = '#f59e0b'; // æ©™è‰²ï¼šShift è¿é€‰æ¨¡å¼
                            lineWidth = 2.5;
                        } else if (isSingleActive) {
                            color = '#ef4444'; // çº¢è‰²ï¼šå½“å‰ç¼–è¾‘è¡Œ
                            lineWidth = 2.5;
                        } else if (active) {
                            // åŒºåŸŸå†…è¾…åŠ©é«˜äº®
                            if (lIdx === maxSizeIdx) { 
                                color = '#c084fc'; // ç´«è‰²ï¼šæœ€å¤§è¡Œ
                                lineWidth = 2.5; 
                            } else if (lIdx === minSizeIdx) { 
                                color = '#f472b6'; // ç²‰è‰²ï¼šæœ€å°è¡Œ
                                lineWidth = 2.5; 
                            }
                        }

                        // ç»˜åˆ¶è¾¹æ¡†
                        ctx.strokeStyle = color;
                        ctx.lineWidth = lineWidth;
                        ctx.beginPath();
                        line.forEach((p, pi) => pi === 0 ? ctx.moveTo(p[0], p[1]) : ctx.lineTo(p[0], p[1]));
                        ctx.closePath();
                        ctx.stroke();

                        // --- 4. ç»˜åˆ¶çº¢è‰²åºå·ï¼ˆä»…å¤šé€‰æ¨¡å¼ï¼‰ ---
                        if (isMultiSelected) {
                            // A. è®¡ç®—ç¼©æ”¾è‡ªé€‚åº”çš„å­—ä½“å¤§å°
                            const fs = Math.max(12, 18 / viewState.scale);
                            ctx.font = `bold ${fs}px sans-serif`;
                            
                            const isV = r.direction === 'v'; // æ˜¯å¦å‚ç›´æ’ç‰ˆ
                            const offset = 5 / viewState.scale;
                            let dx, dy;

                            // B. æ ¹æ®æ¨ªçºµæ’ç‰ˆè®¡ç®—åºå·ä½ç½®
                            if (isV) {
                                // å‚ç›´æ’ç‰ˆï¼šåºå·åœ¨é¡¶éƒ¨ä¸­å¿ƒ
                                dx = (line[0][0] + line[1][0]) / 2;
                                dy = Math.min(line[0][1], line[1][1]) - offset;
                                ctx.textAlign = 'center'; 
                                ctx.textBaseline = 'bottom';
                            } else {
                                // æ°´å¹³æ’ç‰ˆï¼šåºå·åœ¨å·¦ä¾§ä¸­å¿ƒ
                                dx = Math.min(line[0][0], line[3][0]) - offset;
                                dy = (line[0][1] + line[3][1]) / 2;
                                ctx.textAlign = 'right'; 
                                ctx.textBaseline = 'middle';
                            }

                            // C. æ‰§è¡Œç»˜åˆ¶ï¼šå…ˆæè¾¹ï¼ˆé˜²æ‰è‰²ï¼‰å†å¡«è‰²
                            // è¿™é‡Œçš„ multiIdx + 1 å³æˆ‘ä»¬è®¨è®ºçš„ selectOrder + 1
                            const displayIdx = selectOrder + 1; 

                            ctx.strokeStyle = "white"; 
                            ctx.lineWidth = 3 / viewState.scale;
                            ctx.strokeText(displayIdx, dx, dy);
                            
                            ctx.fillStyle = "#f59e0b"; // ä½¿ç”¨æ©™è‰²å‘¼åº”å¤šé€‰çŠ¶æ€ï¼Œæˆ–ä¿æŒä½ çš„ #ef4444 çº¢è‰²
                            ctx.fillText(displayIdx, dx, dy);
                        }

                        // 3. ç»“æŸå½“å‰è¡Œçš„ç»˜åˆ¶
                        ctx.restore();
                    });
                }

                // --- ã€B. æ€»æ¡†æ¸²æŸ“ (Big Blocks)ã€‘ ---
                // é€»è¾‘ï¼šå¼€å¯â€œæ€»â€å¼€å…³ï¼Œæˆ–è€…è¯¥åŒºåŸŸæ˜¯é€‰ä¸­çš„ï¼Œæ‰ç”»å¤–å£³å¤§æ¡†
                if (r.box && (showBlocks || active)) {
                    
                    drawAngleBox(r, active); 
                    
                    // åªæœ‰å¼€å¯â€œæ€»â€å¼€å…³ï¼Œæ‰æ˜¾ç¤º #1, #2 è¿™ç§ç¼–å·æ ‡ç­¾
                    if (showBlocks) {
                        drawBoxLabels(r, i, active); 
                    }
                }

                // --- ã€C. æ‰‹æŸ„æ¸²æŸ“ (Handles)ã€‘ ---
                // åªæœ‰å½“å‰é€‰ä¸­çš„åŒºåŸŸæ‰æ˜¾ç¤ºæ“ä½œæ‰‹æŸ„
                if (active) {
                    // è¯‘æ–‡æ¨¡å¼æ˜¾ç¤ºå¤§æ¡†æ‰‹æŸ„
                    if (displayMode !== 'original') {
                        drawHandles(r); 
                    }
                    
                    // åŸæ–‡æ¨¡å¼æ˜¾ç¤ºå°æ¡†æ‰‹æŸ„
                    if (displayMode !== 'translation' && r.lines) {
                        // ã€æ ¸å¿ƒä¿®æ”¹ã€‘ï¼šåœ¨è¿™é‡Œå¢åŠ  lIdx (è¡Œç´¢å¼•) çš„åˆ¤æ–­
                        r.lines.forEach((line, lIdx) => {
                            // åªæœ‰å½“è¿™ä¸€è¡Œçš„ç´¢å¼•ç­‰äºå½“å‰ç‚¹ä¸­çš„ç´¢å¼•æ—¶ï¼Œæ‰ç”»å®ƒçš„æ‰‹æŸ„
                            if (lIdx !== activeLineIndex) return; 

                            // æ‰¾åˆ°ç»˜åˆ¶å°æ¡†æ§åˆ¶ç‚¹çš„å¾ªç¯
                            const lineHandles = getLineHandles(line);
                            lineHandles.forEach(h => {
                                // 1. ç»˜åˆ¶è¿æ¥çº¿ä¿åº•
                                if (h.type === 'rotate-line') {
                                    ctx.beginPath();
                                    ctx.moveTo(h.anchorX, h.anchorY);
                                    ctx.lineTo(h.x, h.y);
                                    ctx.strokeStyle = '#8b5cf6';
                                    ctx.lineWidth = Math.max(1, 2 / viewState.scale); // ä¿åº• 1px
                                    ctx.stroke();
                                }
                                // 2. ç»˜åˆ¶æ§åˆ¶ç‚¹åœ†åœˆä¿åº•
                                ctx.beginPath();
                                const r = Math.max(3, 4 / viewState.scale); // ä¿åº•åŠå¾„ 3px
                                ctx.arc(h.x, h.y, r, 0, Math.PI * 2);
                                ctx.fillStyle = h.type === 'rotate-line' ? '#c084fc' : '#3b82f6'; 
                                ctx.fill(); 
                                ctx.strokeStyle = '#ffffff';
                                ctx.lineWidth = Math.max(1, 1 / viewState.scale); // ä¿åº•çº¿å®½ 1px
                                ctx.stroke();
                            });
                        });
                    }
                }
            });
            // --- åœ¨ draw() å‡½æ•°æœ€åæ·»åŠ é¢„è§ˆé€»è¾‘ ---
            if (isDrawingMode && tempDrawRect) {
                ctx.save();
                ctx.strokeStyle = '#f59e0b'; // æ©™è‰²é¢„è§ˆ
                ctx.lineWidth = 2 / viewState.scale;
                ctx.strokeRect(tempDrawRect.x, tempDrawRect.y, tempDrawRect.w, tempDrawRect.h);
                ctx.restore();
            }
        }

        function drawBoxLabels(region, index, isActive) {
            const [x1, y1, x2, y2] = region.box; const w = x2 - x1, h = y2 - y1;
            const cx = x1 + w/2, cy = y1 + h/2;
            ctx.save(); 
            ctx.translate(cx, cy); 
            ctx.rotate(region.angle * Math.PI / 180); 
            ctx.translate(-w/2, -h/2);
            
            // âœ… [ä¿®æ”¹ 1] ç»Ÿä¸€å›ºå®šå¤§å°ï¼Œä¸å†éšå­—å·å˜åŒ–
            // è®¾å®šä¸º 12px (å¾ˆå°ä½†èƒ½çœ‹æ¸…)ï¼Œé¿å…é®æŒ¡
            const labelFontSize = 12; 
            
            const regionFontSize = region.font_size || 20;
            ctx.font = `bold ${labelFontSize}px sans-serif`;
            
            const angleText = (Math.abs(region.angle) > 0.1) ? ` A:${Math.round(region.angle)}Â°` : '';
            const sizeText = `Sz:${regionFontSize.toFixed(1)}`;
            const labelText = `#${index+1} ${sizeText}${angleText}`;
            
            const padding = 3; // å‡å°å†…è¾¹è·
            const textWidth = ctx.measureText(labelText).width;
            
            // âœ… [ä¿®æ”¹ 2] å¤§å¹…æé«˜é€æ˜åº¦ (Alphaå€¼è°ƒä½)
            // é€‰ä¸­æ—¶: 0.85 -> 0.6 (åŠé€æ˜çº¢)
            // æœªé€‰ä¸­: 0.7 -> 0.25 (é«˜é€æ˜é»‘ç°ï¼Œå‡ ä¹ä¸æŒ¡å›¾)
            ctx.fillStyle = isActive ? "rgba(245, 158, 11, 0.6)" : "rgba(31, 41, 55, 0.25)";
            
            // ç»˜åˆ¶èƒŒæ™¯æ¡†
            ctx.fillRect(0, -labelFontSize - padding * 2 - 2, textWidth + padding * 2, labelFontSize + padding * 2);
            
            // âœ… [ä¿®æ”¹ 3] å­—ä½“ä¹Ÿå¢åŠ é€æ˜åº¦
            // çº¯ç™½ -> 0.85é€æ˜ç™½ï¼Œé™ä½åˆºçœ¼æ„Ÿ
            ctx.fillStyle = "rgba(255, 255, 255, 0.85)"; 
            
            ctx.textBaseline = "top"; 
            ctx.fillText(labelText, padding, -labelFontSize - padding - 2);
            
            ctx.restore();
        }

        function drawAngleBox(region, isActive) {
            const [x1, y1, x2, y2] = region.box; const w = x2 - x1, h = y2 - y1;
            const cx = x1 + w/2, cy = y1 + h/2;
            ctx.save(); ctx.translate(cx, cy); ctx.rotate(region.angle * Math.PI / 180);
            ctx.strokeStyle = isActive ? '#f59e0b' : '#22c55e'; // é¡ºä¾¿æ”¹æˆäº†ä½ æƒ³è¦çš„æ©™è‰²
            ctx.lineWidth = isActive ? 2.5 : 1.5; 
            ctx.strokeRect(-w/2, -h/2, w, h);

            // ã€æ ¸å¿ƒä¿®å¤ã€‘ï¼šå¢åŠ  displayMode !== 'original' åˆ¤æ–­
            // åªæœ‰åœ¨éåŸæ–‡æ¨¡å¼ï¼ˆå³è¯‘æ–‡æ¨¡å¼ï¼‰ä¸‹ï¼Œä¸”è¢«é€‰ä¸­æ—¶ï¼Œæ‰æ˜¾ç¤ºå¤§æ¡†çš„æ—‹è½¬è¿æ¥çº¿
            if (isActive && displayMode !== 'original') {
                ctx.beginPath(); 
                ctx.moveTo(0, -h/2); 
                ctx.lineTo(0, -h/2 - ROTATE_HANDLE_OFFSET);
                ctx.strokeStyle = '#8b5cf6'; 
                ctx.lineWidth = 2; 
                ctx.stroke();
            }
            ctx.restore();
        }

        function drawHandles(region) {
            const handles = getRegionHandles(region);
            const rad = region.angle * Math.PI / 180;

            handles.forEach(h => {
                ctx.save();
                ctx.translate(h.x, h.y); 
                
                // --- ä¿åº•ç­–ç•¥ï¼šç¡®ä¿æ‰‹æŸ„åœ¨å±å¹•ä¸Šè‡³å°‘æœ‰ 5px å¤§ï¼Œçº¿å®½è‡³å°‘ 1px ---
                const baseSize = (h.index >= 4 ? 8 : 10);
                const visualSize = Math.max(10, baseSize / viewState.scale); 
                const strokeW = Math.max(1, 2 / viewState.scale);
                // -------------------------------------------------------

                if (h.type === 'rotate') {
                    ctx.beginPath();
                    // ã€æ ¸å¿ƒä¿®æ”¹ã€‘ï¼šä½¿ç”¨ä¸æ§åˆ¶ç‚¹ä¸€è‡´çš„ visualSize æ¥æ¨å¯¼åŠå¾„
                    // visualSize çš„ä¿åº•æ˜¯ 10ï¼Œè¿™é‡Œå–å…¶ä¸€åŠå†å¾®è°ƒï¼Œç¡®ä¿è§†è§‰å¤§å°ä¸æ–¹å—æ‰‹æŸ„å®Œç¾åŒæ­¥
                    const rotateRadius = (visualSize / 2) + 1; 
                    ctx.arc(0, 0, rotateRadius, 0, Math.PI * 2);
                    ctx.fillStyle = '#8b5cf6';
                } else {
                    ctx.rotate(rad); 
                    ctx.beginPath();
                    ctx.rect(-visualSize/2, -visualSize/2, visualSize, visualSize); 
                    ctx.fillStyle = h.index >= 4 ? '#3b82f6' : '#f59e0b';
                }
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = strokeW;
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            });
        }

        // --- SMART TCY ENGINE (Ultimate Edition) ---
        function drawSmartTranslation(region, onlyPass) {
            // [æ–°å¢] è·å–å½“å‰æ¡†çš„å­—é‡
            const effectiveWeight = region.fontWeight || activeFontWeight;
            
            // === å‚æ•°é…ç½®åŒº ===
            const RUBY_SIZE_RATIO = 0.4;    // Ruby å¤§å°
            const RUBY_OFFSET_RATIO = 0.02; // Ruby ç¦»æ­£æ–‡çš„è·ç¦» (ç´§è´´)

            // [æ–°å¢] ç€é‡å·é…ç½®
            const DOT_RADIUS_RATIO = 0.1;   // ç€é‡å·åŠå¾„ (å³ç›´å¾„æ˜¯ 0.2 å€å­—å·)
            const DOT_OFFSET_RATIO = 0.05;  // ç€é‡å·ç¦»æ­£æ–‡çš„è·ç¦» (ç¨å¾®æ¯” Ruby è¿œä¸€ç‚¹ç‚¹ï¼Œ0.05 æ¯”è¾ƒé€æ°”ï¼Œä¹Ÿå¯è®¾ä¸º 0.02)

            if (!region.translation) return;
            const rawText = region.translation || "";
            let lines = rawText.replace(/ã€BRã€‘/g, '\n').split('\n');
            let boxWidth, boxHeight, angleRad;
            if (region.box) {
                const [x1,y1,x2,y2] = region.box;
                boxWidth = x2 - x1; boxHeight = y2 - y1;
                angleRad = region.angle * Math.PI / 180;
            } else { return; }

            const localMinY = -boxHeight / 2; const localMaxY = boxHeight / 2;
            // åœ¨ drawSmartTranslation å‡½æ•°å¼€å¤´è·å–å‚æ•°çš„éƒ¨åˆ†
            const baseFontSize = region.font_size || 20;

            // ã€ä¿®æ”¹ã€‘å°† letter_spacing è§†ä¸ºå€ç‡ï¼Œè®¡ç®—å‡ºå®é™…åƒç´ é—´è·
            const letterSpacingMult = region.letter_spacing || 0; 
            const letterSpacingPx = baseFontSize * letterSpacingMult; 

            const lineSpacingMult = region.line_spacing; 
            // ... åç»­é€»è¾‘ä¸­ä½¿ç”¨ letterSpacingPx çš„åœ°æ–¹æ— éœ€å˜åŠ¨ï¼Œå› ä¸ºå®ƒå·²ç»æ˜¯è®¡ç®—åçš„åƒç´ å€¼äº†
            const effectiveAlign = region.textAlign || activeTextAlign;
            const effectiveFont = region.fontFamily || activeFontFamily;
            
            const finalFillColor = region.parsedColor || activeTextColor;
            const finalStrokeColor = region.strokeColor || activeStrokeColor;
            const finalStrokeWidthRatio = (region.strokeWidthRatio !== undefined) ? region.strokeWidthRatio : activeStrokeWidth;
            
            const useConcentricFill = region.fill_holes === true; 

            ctx.save();
            const [x1,y1,x2,y2] = region.box; ctx.translate(x1 + boxWidth/2, y1 + boxHeight/2); ctx.rotate(angleRad);
            
            const isVertical = region.direction === 'v';

// === MTU è‡ªåŠ¨æ¢è¡Œé€»è¾‘ (æœ€ç»ˆåƒç´ æ„ŸçŸ¥ç‰ˆï¼šç«–æ’æ¨ªæ’ç»Ÿä¸€é€»è¾‘) ===
            const originalIsMultiLine = region.lines && region.lines.length >= 2;
            const noExplicitBreak = !rawText.includes('ã€BRã€‘');
            const fullText = lines.join(''); 
            
            // åŸºç¡€å­—å· (ç”¨äºè®¡ç®—å®¹é”™)
            const baseH = baseFontSize + letterSpacingPx;

            // é€šç”¨åŸå­æ­£åˆ™
            const atomRegex = /(\[t\][\s\S]*?\[\/t\])|(\[[^\]]+\])|([\d\uFF10-\uFF19]{2,4})|([\s\S])/gi;
            const atoms = fullText.match(atomRegex) || [];

            // ä¸´æ—¶è®¾ç½®å­—ä½“ä»¥ä¾¿å‡†ç¡®æµ‹é‡
            ctx.font = `${activeFontWeight} ${baseFontSize}px ${effectiveFont.replace(/"/g,'')}`;

            if (isVertical) {
                // === ç«–æ’è‡ªåŠ¨æ¢è¡Œ (Vertical Auto-Wrap) [åƒç´ çº§ç²¾ç¡®ç‰ˆ] ===
                const longestLineLen = Math.max(...lines.map(l => l.replace(/\[.*?\]/g, '').length));
                
                // ä¼°ç®—æ€»é«˜åº¦ (ä»…ç”¨äºè§¦å‘æ¡ä»¶ï¼Œé˜²æ­¢çŸ­æ–‡æœ¬è¯¯åˆ¤)
                const totalEstimatedH = fullText.length * baseFontSize;
                const exceedsBoundsV = totalEstimatedH > boxHeight * 1.05;

                // === ç«–æ’è‡ªåŠ¨æ¢è¡Œ (ä¿®å¤å¯Œæ–‡æœ¬ç»§æ‰¿ç‰ˆ) ===
                if (originalIsMultiLine && noExplicitBreak && exceedsBoundsV) {
                    const newLines = [];
                    let currentLineStr = "";
                    let currentPixelH = 0;
                    let activeTagsStack = []; 
                    const maxPixelsHeight = boxHeight + (baseFontSize * 0.05);

                    atoms.forEach(atom => {
                        let atomH = 0;

                        // ã€ä¿®æ”¹ç‚¹ï¼šå¢åŠ åˆæ³•æ ‡ç­¾æ ¡éªŒã€‘
                        const tagMatch = atom.match(/^\[([a-z]+)(?:=[^\]]*)?\]$/i);

                        if (tagMatch && !atom.startsWith('[/')) {
                            activeTagsStack.push(atom);
                        } else if (atom.startsWith('[/')) {
                            activeTagsStack.pop();
                        }

                        if (atom.startsWith('[') && !atom.startsWith('[/')) {
                            activeTagsStack.push(atom);
                        } else if (atom.startsWith('[/')) {
                            activeTagsStack.pop();
                        }

                        if (atom.startsWith('[')) {
                            atomH = /^\[t\]/i.test(atom) ? baseH : 0; 
                        } else if (atom.length >= 2 && /[\d\uFF10-\uFF19]/.test(atom)) { 
                            atomH = baseH; 
                        } else {
                            // ã€å…³é”®ä¿®å¤ã€‘ï¼šå…ˆåˆ¤æ–­æ˜¯å¦å±äºéœ€è¦å‹ç¼©çš„åŠé«˜ç¬¦å·ï¼ˆæ‹¬å·ã€å¥è¯»ï¼‰
                            if (CHARS_SYMMETRIC_HALF.includes(atom) || CHARS_VERTICAL_COMPRESSION.includes(atom)) {
                                atomH = (baseFontSize * 0.5) + letterSpacingPx;
                            } 
                            else {
                                const isAscii = /^[\x20-\x7E]$/.test(atom);
                                const isRotated = ROTATED_LETTERS_NUMBERS.includes(atom);
                                if (isAscii || isRotated) {
                                    // æ­¤æ—¶æµ‹é‡çš„å®½åº¦å°±æ˜¯æ—‹è½¬åå æ®çš„é«˜åº¦
                                    atomH = ctx.measureText(atom).width + letterSpacingPx;
                                } else {
                                    atomH = baseH;
                                }
                            }
                        }

                        if (currentPixelH + atomH > maxPixelsHeight) {
                            // ã€ä¿®æ”¹ç‚¹ï¼šå®‰å…¨è§£ææ ‡ç­¾åã€‘
                            const closingTags = activeTagsStack.map(t => {
                                const m = t.match(/\[([a-z]+)/i);
                                return m ? `[/${m[1]}]` : "";
                            }).reverse().join('');
                            
                            const openingTags = activeTagsStack.join('');
                            newLines.push(currentLineStr + closingTags);
                            currentLineStr = openingTags + atom;
                            currentPixelH = atomH;
                        } else {
                            currentLineStr += atom;
                            currentPixelH += atomH;
                        }
                    });
                    if (currentLineStr) newLines.push(currentLineStr);
                    lines = newLines;
                }

            } else {
                // === æ¨ªæ’è‡ªåŠ¨æ¢è¡Œ (Horizontal Auto-Wrap) [åƒç´ çº§ç²¾ç¡®ç‰ˆ] ===
                const approxCharW = baseFontSize; 
                const totalVisualWidth = fullText.length * approxCharW; 
                const exceedsBoundsH = totalVisualWidth > boxWidth * 1.05;

                // === æ¨ªæ’è‡ªåŠ¨æ¢è¡Œ (ä¿®å¤å¯Œæ–‡æœ¬ç»§æ‰¿ç‰ˆ) ===
                if (originalIsMultiLine && noExplicitBreak && exceedsBoundsH) {
                    const newLines = [];
                    let currentLineStr = "";
                    let currentPixelW = 0;
                    let activeTagsStack = []; // è¿½è¸ªå½“å‰æ‰“å¼€çš„æ ‡ç­¾

                    let maxPixelsWidth = boxWidth;
                    if (Math.abs(region.angle || 0) > 1) {
                        maxPixelsWidth -= (baseFontSize * 0.5);
                    }

                    atoms.forEach(atom => {
                        let atomW = 0;

                        // ã€ä¿®æ”¹ç‚¹ï¼šå¢åŠ åˆæ³•æ ‡ç­¾æ ¡éªŒã€‘
                        const tagMatch = atom.match(/^\[([a-z]+)(?:=[^\]]*)?\]$/i); 
                        
                        if (tagMatch && !atom.startsWith('[/')) {
                            activeTagsStack.push(atom); // åªæœ‰çœŸæ­£çš„æ ‡ç­¾ [tag] æˆ– [tag=val] æ‰å…¥æ ˆ
                        } else if (atom.startsWith('[/')) {
                            activeTagsStack.pop();
                        }

                        // è¿½è¸ªæ ‡ç­¾çŠ¶æ€
                        if (atom.startsWith('[') && !atom.startsWith('[/')) {
                            activeTagsStack.push(atom); // è®°å½•å¼€æ ‡ç­¾
                        } else if (atom.startsWith('[/')) {
                            activeTagsStack.pop(); // é—­æ ‡ç­¾å‡ºæ ˆ
                        }

                        if (atom.startsWith('[')) {
                            atomW = 0; 
                        } else {
                            if (CHARS_SYMMETRIC_HALF.includes(atom) || CHARS_HORIZONTAL_COMPRESSION.includes(atom)) {
                                atomW = (baseFontSize * 0.5) + letterSpacingPx;
                            } else {
                                atomW = ctx.measureText(atom).width + letterSpacingPx;
                            }
                        }

                        if (currentPixelW + atomW > maxPixelsWidth) {
                            // ã€ä¿®æ”¹ç‚¹ï¼šå®‰å…¨è§£ææ ‡ç­¾åã€‘
                            const closingTags = activeTagsStack.map(t => {
                                const m = t.match(/\[([a-z]+)/i);
                                return m ? `[/${m[1]}]` : ""; // å¦‚æœåŒ¹é…ä¸åˆ°å­—æ¯ï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²
                            }).reverse().join('');
                            
                            const openingTags = activeTagsStack.join('');
                            newLines.push(currentLineStr + closingTags);
                            currentLineStr = openingTags + atom;
                            currentPixelW = atomW;
                        } else {
                            currentLineStr += atom;
                            currentPixelW += atomW;
                        }
                    });

                    if (currentLineStr) newLines.push(currentLineStr);
                    lines = newLines;
                }
            }

            const processedLines = lines.map(lineStr => {
                const tokens = parseRichText(lineStr);
                if (isVertical) {
                    const groupedTokens = [];
                    let currentTcyGroup = null;

                    tokens.forEach(tok => {
                        // 1. å¦‚æœæ˜¯ç”¨æˆ·æ‰‹åŠ¨åŠ äº† [t] æ ‡ç­¾ï¼Œå§‹ç»ˆæ‰§è¡Œ TCY
                        if (tok.style.tcy) {
                            if (!currentTcyGroup) {
                                currentTcyGroup = { isGroup: true, text: "", subTokens: [], style: { tcy: true } };
                                groupedTokens.push(currentTcyGroup);
                            }
                            currentTcyGroup.subTokens.push(tok);
                            currentTcyGroup.text += tok.text;
                        } 
                        // 2. å¦‚æœå¼€å¯äº†è‡ªåŠ¨ TCY ä¸”æ˜¯çº¯æ–‡æœ¬
                        else if (activeAutoTcy) {
                            currentTcyGroup = null;
                            const regex = /([\d\uFF10-\uFF19]+)/g; 
                            let match, lastIndex = 0;

                            while ((match = regex.exec(tok.text)) !== null) {
                                const fullMatch = match[0];
                                if (match.index > lastIndex) {
                                    groupedTokens.push({ text: tok.text.substring(lastIndex, match.index), style: { ...tok.style } });
                                }
                                // ä»…å¯¹ 2-4 ä½æ•°å­—è‡ªåŠ¨ TCY
                                if (fullMatch.length >= 2 && fullMatch.length <= 4) {
                                    groupedTokens.push({ 
                                        isGroup: true, 
                                        text: fullMatch, 
                                        subTokens: [{ text: fullMatch, style: { ...tok.style, tcy: true } }], 
                                        style: { tcy: true } 
                                    });
                                } else {
                                    groupedTokens.push({ text: fullMatch, style: { ...tok.style } });
                                }
                                lastIndex = regex.lastIndex;
                            }
                            if (lastIndex < tok.text.length) {
                                groupedTokens.push({ text: tok.text.substring(lastIndex), style: { ...tok.style } });
                            }
                        } 
                        // 3. å…³é—­äº†è‡ªåŠ¨ TCYï¼Œç›´æ¥ä½œä¸ºæ™®é€šæ–‡æœ¬
                        else {
                            currentTcyGroup = null;
                            groupedTokens.push(tok);
                        }
                    });
                    return groupedTokens;
                }
                return tokens;
            });

            // === [æ–°å¢] åŠ¨æ€å¸ƒå±€è®¡ç®— (Dynamic Layout Engine) ===
            // æ‰«ææ¯ä¸€è¡Œï¼Œåˆ¤æ–­æ˜¯å¦éœ€è¦å› ä¸º Ruby æˆ– ç€é‡å· è€Œæ’‘å¼€é—´è·
            // === [ä¿®æ­£] åŠ¨æ€å¸ƒå±€è®¡ç®—ï¼šæ”¯æŒ Ruby ä¸ç€é‡å·å…±å­˜ ===
            const lineLayouts = processedLines.map(tokens => {
                let hasRuby = false;
                let hasDot = false;
                
                const checkToken = (tok) => {
                    if (tok.style.ruby) hasRuby = true;
                    if (tok.style.dot) hasDot = true;
                    if (tok.subTokens) tok.subTokens.forEach(checkToken);
                };
                tokens.forEach(checkToken);

                const userGap = baseFontSize * (lineSpacingMult - 1);
                let requiredGap = userGap;

                // è®¡ç®—å„ç»„ä»¶æ‰€éœ€ç©ºé—´
                const rubySpace = baseFontSize * (RUBY_SIZE_RATIO + 0.05);
                const dotSpace = baseFontSize * (DOT_RADIUS_RATIO * 2 + DOT_OFFSET_RATIO + 0.05);

                if (hasRuby && hasDot) {
                    // ã€æ ¸å¿ƒä¿®æ”¹ã€‘ï¼šä¸¤è€…å…±å­˜æ—¶ï¼Œé—´è·ç´¯åŠ 
                    requiredGap = Math.max(requiredGap, rubySpace + dotSpace);
                } else if (hasRuby) {
                    requiredGap = Math.max(requiredGap, rubySpace);
                } else if (hasDot) {
                    requiredGap = Math.max(requiredGap, dotSpace);
                }

                return { hasRuby, hasDot, gap: requiredGap, thickness: baseFontSize };
            });

            // è®¡ç®—æ€»å®½é«˜ (ç”¨äºæ•´ä½“å±…ä¸­)
            const totalContentSize = lineLayouts.reduce((sum, layout) => sum + layout.thickness + layout.gap, 0) - lineLayouts[0].gap; 
            // æ³¨æ„ï¼šç¬¬ä¸€è¡Œä¸éœ€è¦å‰ç½® Gapï¼Œæ‰€ä»¥å‡å» lineLayouts[0].gap

            // === [æ–°å¢] 2. å°†å¸ƒå±€è½¬æ¢ä¸ºå…·ä½“çš„åæ ‡ (Coordinate Calculation) ===
            // æˆ‘ä»¬éœ€è¦åœ¨ renderPass ä¹‹å‰å°±æŠŠæ¯ä¸€è¡Œçš„ç¡®åˆ‡ä½ç½®ç®—å¥½ï¼Œ
            // è¿™æ · stroke(æè¾¹) å’Œ fill(å¡«å……) ä¸¤éå¾ªç¯æ—¶ï¼Œä½ç½®æ‰èƒ½å®Œå…¨é‡åˆã€‚

            const linePositions = []; 

            if (isVertical) {
                // --- ç«–æ’æ¨¡å¼ (ä»å³å‘å·¦æ’ï¼ŒX å˜å°) ---
                // 1. ç¡®å®šæœ€å³è¾¹çš„èµ·ç‚¹ï¼šç”±äºæ˜¯å±…ä¸­å¯¹é½ï¼Œèµ·ç‚¹ = å®¹å™¨ä¸­å¿ƒ + æ€»å†…å®¹å®½åº¦çš„ä¸€åŠ
                let currentEdge = totalContentSize / 2; 
                
                lineLayouts.forEach((layout, i) => {
                    // 2. å‡å»å‰ç½®é—´è· (Gap)
                    // ç¬¬ä¸€è¡Œä¸éœ€è¦å‡ gapï¼Œå› ä¸ºå®ƒæ˜¯èµ·å§‹è¡Œï¼›åç»­è¡Œè¦é¿å¼€ä¸Šä¸€è¡Œçš„ Ruby
                    if (i > 0) currentEdge -= layout.gap;
                    
                    // 3. è®¡ç®—å½“å‰è¡Œçš„ä¸­å¿ƒçº¿ X åæ ‡
                    // è¿™ä¸€è¡Œçš„å·¦è¾¹æ˜¯ currentEdge - thicknessï¼Œå³è¾¹æ˜¯ currentEdge
                    // æ‰€ä»¥ä¸­å¿ƒç‚¹ = currentEdge - (thickness / 2)
                    const centerX = currentEdge - (layout.thickness / 2);
                    linePositions.push(centerX);
                    
                    // 4. ç§»åŠ¨è¾¹ç¼˜åˆ°ä¸‹ä¸€è¡Œçš„å¼€å§‹ä½ç½®
                    currentEdge -= layout.thickness;
                });

            } else {
                // --- æ¨ªæ’æ¨¡å¼ (ä»ä¸Šå‘ä¸‹æ’ï¼ŒY å˜å¤§) ---
                // 1. ç¡®å®šæœ€ä¸Šè¾¹çš„èµ·ç‚¹ï¼šèµ·ç‚¹ = å®¹å™¨ä¸­å¿ƒ - æ€»å†…å®¹é«˜åº¦çš„ä¸€åŠ
                let currentEdge = -totalContentSize / 2;
                
                lineLayouts.forEach((layout, i) => {
                    // 2. åŠ ä¸Šå‰ç½®é—´è· (Gap)
                    if (i > 0) currentEdge += layout.gap;
                    
                    // 3. è®¡ç®—å½“å‰è¡Œçš„ä¸­å¿ƒçº¿ Y åæ ‡
                    const centerY = currentEdge + (layout.thickness / 2);
                    linePositions.push(centerY);
                    
                    // 4. ç§»åŠ¨è¾¹ç¼˜åˆ°ä¸‹ä¸€è¡Œçš„å¼€å§‹ä½ç½®
                    currentEdge += layout.thickness;
                });
            }
            // --- Render Logic (Two Pass) ---
            function renderPass(mode) {
                const isGlow = mode === 'glow';
                const isStroke = mode === 'stroke';
                const isFill = mode === 'fill';

                // çŠ¶æ€æ‹¦æˆª
                if (isGlow && !region.blurEnable) return;
                if (isStroke && (!activeStrokeEnabled || finalStrokeWidthRatio <= 0)) return;

                ctx.save();

                // --- å…¨å±€æ ·å¼é…ç½® ---
                // è·å–åœ†è§’å¼€å…³çŠ¶æ€
                const isRound = document.getElementById('strokeRound').checked;
                ctx.lineJoin = isRound ? 'round' : 'miter';
                ctx.lineCap = isRound ? 'round' : 'butt';

                if (isGlow) {
                    // 1. è®¾ç½®åç§»é‡ï¼ˆæŠŠå®å¿ƒæ–‡å­—æ‰”åˆ°ç”»å¸ƒå¤– 5000 åƒç´ çš„åœ°æ–¹ï¼‰
                    const offset = 5000;
                    
                    // 2. é…ç½®å‘å…‰å±æ€§
                    const ratio = region.blurSizeRatio || 0.1; // é»˜è®¤ç»™ 0.1 å€å­—å·
                    
                    ctx.shadowColor = region.blurColor || "#000000";
                    // å…³é”®ä¿®æ”¹ï¼šä¹˜ä»¥å½“å‰åŸºå‡†å­—å·
                    ctx.shadowBlur = baseFontSize * ratio;
                    
                    // 3. å…³é”®ï¼šé˜´å½±åç§»è®¾ä¸ºè´Ÿå€¼ï¼ŒæŠŠå…‰æ™•æ‹‰å›åŸä½
                    ctx.shadowOffsetX = -offset; 
                    ctx.shadowOffsetY = 0;
                    
                    // 4. è®©æ•´ä¸ªåæ ‡ç³»ä¸´æ—¶å‘å³ç§»åŠ¨ï¼Œè¿™æ ·ç”»å‡ºæ¥çš„æ–‡å­—å°±åœ¨å¤–é¢äº†
                    ctx.translate(offset, 0);

                    // åŸºç¡€é¢œè‰²è®¾ç½®
                    ctx.fillStyle = region.blurColor || "#000000";
                    ctx.strokeStyle = region.blurColor || "#000000";
                }else {
                    // æè¾¹å’Œå¡«å……å±‚å¿…é¡»å…³é—­å‘å…‰ï¼Œå¦åˆ™ä¼šæ¨¡ç³Š
                    ctx.shadowBlur = 0; 
                    if (isStroke) {
                        ctx.strokeStyle = finalStrokeColor;
                        ctx.lineWidth = baseFontSize * finalStrokeWidthRatio;
                    } else if (isFill) {
                        ctx.fillStyle = finalFillColor;
                    }
                }

                // æŠ½è±¡ç»˜åˆ¶åŠ¨ä½œï¼šæ ¹æ®å½“å‰ pass å†³å®šè°ƒç”¨ stroke è¿˜æ˜¯ fill
                const executeDraw = (char, dx, dy) => {
                    if (isFill) {
                        ctx.fillText(char, dx, dy);
                    } else if (isStroke) {
                        ctx.strokeText(char, dx, dy);
                    } else if (isGlow) {
                        // å…³é”®ï¼šå‘å…‰å±‚å¿…é¡»çœŸçš„ç”»å‡ºå†…å®¹ï¼Œé˜´å½±æ‰ä¼šå‡ºç°
                        // æˆ‘ä»¬ç”¨ fillText æ¥æ‰¿è½½é˜´å½±
                        ctx.fillText(char, dx, dy); 
                    }
                };

                if (isVertical) {
                    // === [æ ¸å¿ƒä¿®å¤] ç«–æ’é«˜åº¦æµ‹é‡ (Block Alignment Measurement) ===
                    // è¿™ä¸€æ­¥å†³å®šäº†"æ•´åˆ—æ–‡å­—"æœ‰å¤šé«˜ï¼Œä»è€Œå†³å®šäº†å®ƒåœ¨æ¡†é‡Œæ€ä¹ˆå±…ä¸­ã€‚
                    // å¿…é¡»å’Œç»˜åˆ¶é€»è¾‘ã€æ¢è¡Œé€»è¾‘ä¿æŒ 100% ä¸€è‡´ã€‚
                    
                    // === ä¿®å¤ç«–æ’å—å±…ä¸­åç§»ï¼šå¯¹é½æµ‹é‡é€»è¾‘ ===
                    const lineMetrics = processedLines.map(tokens => {
                        let h = 0;
                        tokens.forEach(tok => {
                            const fSize = baseFontSize * (tok.style.scale || 1.0);
                            // ä¸´æ—¶è®¾ç½®å­—ä½“ä»¥ä¾¿æµ‹é‡
                            ctx.font = `${tok.style.italic === true ? 'italic ' : ''}${tok.style.bold ? 'bold ' : effectiveWeight} ${fSize}px ${tok.style.font || effectiveFont.replace(/"/g, '')}`;
                            
                            if (tok.isGroup || tok.style.tcy) {
                                h += fSize + letterSpacingPx + (tok.style.kerning || 0) * fSize;
                            } 
                            else {
                                for (const char of tok.text) {
                                    let charH;
                                    
                                    // ã€æ ¸å¿ƒä¿®å¤ã€‘ï¼šè¿™é‡Œçš„é€»è¾‘å¿…é¡»ä¸ä¸‹é¢çš„ç»˜åˆ¶å¾ªç¯ 100% ä¸€è‡´
                                    // 1. ä¼˜å…ˆåˆ¤æ–­åŠé«˜å¯¹ç§°ç¬¦å·ï¼ˆæ‹¬å·ç±»ï¼‰
                                    if (CHARS_SYMMETRIC_HALF.includes(char) || CHARS_VERTICAL_COMPRESSION.includes(char)) {
                                        charH = fSize * 0.5;
                                    } 
                                    // 2. æ—‹è½¬å­—ç¬¦ï¼ˆè‹±æ–‡ã€æ•°å­—ã€åŠ¨æ€ä¸­å¿ƒç¬¦å·ï¼‰
                                    else if (ROTATED_LETTERS_NUMBERS.includes(char) || /^[\x20-\x7E]$/.test(char)) {
                                        charH = ctx.measureText(char).width;
                                    } 
                                    // 3. æ™®é€šæ±‰å­—
                                    else {
                                        charH = getCharVerticalHeight(char, fSize);
                                    }

                                    h += charH + letterSpacingPx + (tok.style.kerning || 0) * fSize;
                                }
                            }
                        });
                        if (h > 0) h -= letterSpacingPx; // å»æ‰æœ€åä¸€ä¸ªå­—ç¬¦å¤šç®—çš„é—´è·
                        return h;
                    });
                                        
                    // ... (åé¢æ˜¯ processedLines.forEach ç»˜åˆ¶å¾ªç¯) ...

                    processedLines.forEach((tokens, i) => {
                        const currentLineH = lineMetrics[i];
                        let currentY;
                        if (effectiveAlign === 'column-center') currentY = localMinY + (boxHeight - currentLineH) / 2;
                        else if (effectiveAlign === 'block-top') currentY = localMinY; 
                        else if (effectiveAlign === 'block-bottom') currentY = localMaxY - currentLineH; 
                        else currentY = localMinY + (boxHeight - Math.max(...lineMetrics)) / 2;
                        // const x = (totalWidth / 2) - (i * colStep) - (colStep / 2);
                        // âœ… [æ–°ä»£ç ] ç›´æ¥è¯»å–åˆšæ‰ç®—å¥½çš„åæ ‡
                        const x = linePositions[i];

                        tokens.forEach(tok => {
                            if (tok.isGroup) { // --- TCY (çºµä¸­æ¨ª) æ¸²æŸ“é€»è¾‘ ---
                                const fSize = baseFontSize; 
                                const segmentHeight = fSize; 
                                const charY = currentY + segmentHeight / 2;
                                let totalGroupWidth = 0;

                                // 1. é¢„æµ‹é‡é˜¶æ®µï¼šè®¡ç®—æ‰€æœ‰å­ Token çš„æ€»è§†è§‰å®½åº¦
                                tok.subTokens.forEach(sub => {
                                    const subFSize = fSize * (sub.style.scale || 1.0);
                                    // [å…³é”®]ï¼šåœ¨æµ‹é‡å’Œæ˜¾ç¤ºå‰ï¼Œå°†å…¨è§’æ•°å­—è½¬ä¸ºåŠè§’ï¼Œä»¥è·å¾—çœŸå®çš„æ¯”ä¾‹å®½åº¦
                                    sub._drawText = sub.text.replace(/[ï¼-ï¼™]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xfee0));
                                    
                                    ctx.font = `${sub.style.italic === true ? 'italic ' : ''}${sub.style.bold ? 'bold ' : effectiveWeight} ${subFSize}px ${sub.style.font || effectiveFont.replace(/"/g, '')}`;
                                    
                                    // ç´¯åŠ è§†è§‰å®½åº¦è€Œéå›ºå®š 1em å®½åº¦
                                    const metrics = ctx.measureText(sub._drawText);
                                    sub._metricsWidth = metrics.width; // ç¼“å­˜å®½åº¦
                                    totalGroupWidth += sub._metricsWidth + (sub.style.kerning ? sub.style.kerning * subFSize : 0);
                                });

                                // 2. è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼šç›®æ ‡å®½åº¦æ”¾å®½åˆ° 1.1em ä»¥å‡å°‘å‹ç¼©æ„Ÿ
                                const targetWidth = fSize * 1.1; 
                                let groupScale = (totalGroupWidth > targetWidth) ? (targetWidth / totalGroupWidth) : 1.0;

                                ctx.save(); 
                                ctx.translate(x, charY); 
                                ctx.scale(groupScale, 1);

                                // 3. ç»˜åˆ¶é˜¶æ®µï¼šä½¿ç”¨é¢„å­˜çš„ sub._drawText å’Œ sub._metricsWidth
                                let currentSubX = -totalGroupWidth / 2;
                                tok.subTokens.forEach(sub => {
                                    const subFSize = fSize * (sub.style.scale || 1.0);
                                    ctx.font = `${sub.style.italic === true ? 'italic ' : ''}${sub.style.bold ? 'bold ' : effectiveWeight} ${subFSize}px ${sub.style.font || effectiveFont.replace(/"/g, '')}`;
                                    ctx.lineWidth = subFSize * finalStrokeWidthRatio * (1 / groupScale);

                                    const subW = sub._metricsWidth;
                                    const drawX = currentSubX + subW / 2 + (sub.style.offX || 0);
                                    
                                    ctx.save(); 
                                    ctx.translate(drawX, sub.style.offY || 0);
                                    if (sub.style.rotation) ctx.rotate(sub.style.rotation * Math.PI / 180);
                                    ctx.textAlign = 'center'; 
                                    ctx.textBaseline = 'middle';

                                    // --- ä¿®æ”¹åçš„ TCY ç»˜åˆ¶é€»è¾‘ ---
                                    if (isStroke) {
                                        ctx.strokeText(sub._drawText, 0, 0); 
                                    } else if (isFill || isGlow) { // åŠ ä¸Š isGlow
                                        ctx.fillText(sub._drawText, 0, 0);
                                    }
                                    ctx.restore();
                                    
                                    currentSubX += subW + (sub.style.kerning || 0) * subFSize;
                                });
                                ctx.restore(); 
                                currentY += segmentHeight + letterSpacingPx;
                            } else { 
                                // Normal Vertical
                                const style = tok.style; const fSize = baseFontSize * (style.scale || 1.0);
                                const isManualSkew = (typeof style.italic === 'number'); const skewAngle = isManualSkew ? style.italic : 0;
                                
                                // [è®¾ç½®å­—ä½“] æ­£æ–‡åº”ç”¨ effectiveWeight
                                ctx.font = `${style.italic===true?'italic ':''} ${style.bold ? 'bold' : effectiveWeight} ${fSize}px ${style.font || effectiveFont.replace(/"/g,'')}`;
                                ctx.lineWidth = fSize * finalStrokeWidthRatio;

                                // === 1. é¢„è®¡ç®—ç«–æ’é«˜åº¦ (Pre-calc Heights) ===
                                const charHeights = [];
                                for (const char of tok.text) {
                                    let h;
                                    let isSymmetric = false; // æ ‡è®°æ˜¯å¦ä¸º"æ—‹è½¬ä¸”å¯¹ç§°"çš„ç¬¦å·(å¦‚æ‹¬å·)

                                    if (CHARS_SYMMETRIC_HALF.includes(char)) {
                                        // 1. æ‹¬å·ç±»ï¼šæ—¢è¦åŠé«˜ï¼Œåˆè¦æ—‹è½¬/å±…ä¸­
                                        isSymmetric = true;
                                        h = fSize * 0.5;
                                    } 
                                    else if (CHARS_VERTICAL_COMPRESSION.includes(char)) {
                                        // 2. å¥è¯»ç‚¹(ï¼Œã€‚ã€)ï¼šåªè¦åŠé«˜ï¼Œä½†ã€ä¸è¦ã€‘æ—‹è½¬ (isSymmetric = false)
                                        // è¿™æ ·å®ƒä»¬å°±ä¼šè¿›å…¥ !needsRotation åˆ†æ”¯ï¼Œå»æ‰§è¡Œå³ä¸Šè§’åç§»é€»è¾‘
                                        isSymmetric = false; 
                                        h = fSize * 0.5;
                                    }
                                    else {
                                        // 3. æ™®é€šå­—ç¬¦
                                        if (ROTATED_LETTERS_NUMBERS.includes(char)) h = ctx.measureText(char).width;
                                        else h = getCharVerticalHeight(char, fSize);
                                    }
                                    
                                    const spacing = letterSpacingPx + (style.kerning || 0) * fSize;
                                    charHeights.push({ h: h, spacing: spacing, char: char, isSymmetric: isSymmetric });
                                }

                                // === 2. Ruby é€»è¾‘ (è‡ªåŠ¨é€‚é…å‹ç¼©é«˜åº¦) ===
                                if (style.ruby) {
                                    ctx.save();
                                    const rubyFontSize = fSize * RUBY_SIZE_RATIO;
                                    // [è®¾ç½®å­—ä½“] æ³¨éŸ³ä¸è·Ÿéš effectiveWeight (é™¤éæœ‰[b])
                                    const rubyFont = `${style.bold ? 'bold' : ''} ${rubyFontSize}px ${style.font || effectiveFont.replace(/"/g,'')}`;
                                    ctx.font = rubyFont;
                                    
                                    const rubyText = style.ruby;
                                    const rubyCount = rubyText.length;
                                    const rubyRawHeight = rubyCount * rubyFontSize;
                                    
                                    // è®¡ç®—æ­£æ–‡æ€»é«˜åº¦ (è¯»å–å·²ç»å‹ç¼©è¿‡çš„ h)
                                    let tokenTotalHeight = 0; 
                                    charHeights.forEach(item => tokenTotalHeight += item.h + item.spacing);
                                    if(charHeights.length) tokenTotalHeight -= charHeights[charHeights.length-1].spacing;
                                    
                                    // è®¡ç®— Ruby X åæ ‡
                                    const rubyX = x + (fSize * 0.5) + (rubyFontSize * 0.5) + (fSize * RUBY_OFFSET_RATIO);

                                    // Ruby ç»˜åˆ¶
                                    if (rubyRawHeight <= tokenTotalHeight) {
                                        const slotHeight = tokenTotalHeight / rubyCount;
                                        for (let i = 0; i < rubyCount; i++) {
                                            const charCenterY = currentY + (i * slotHeight) + (slotHeight / 2);
                                            ctx.save(); 
                                            ctx.translate(rubyX, charCenterY);
                                            if (style.rotation) ctx.rotate(style.rotation * Math.PI / 180);
                                            // [åŸæœ‰] æ–œä½“/æ°´å¹³åˆ‡å˜ (Param 3)
                                            if (isManualSkew) ctx.transform(1, 0, Math.tan(skewAngle * Math.PI / 180) * -1, 1, 0, 0);
                                            
                                            // [ä¿®æ”¹] å‚ç›´åˆ‡å˜ (Param 2) - å¢åŠ  * -1 å®ç°å‘ä¸ŠæŠ¬
                                            if (style.vShear) ctx.transform(1, Math.tan(style.vShear * Math.PI / 180) * -1, 0, 1, 0, 0);
                                            ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; 
                                            
                                            if (isStroke) {
                                                ctx.strokeStyle = finalStrokeColor;
                                                ctx.lineWidth = rubyFontSize * finalStrokeWidthRatio; 
                                                ctx.strokeText(rubyText[i], 0, 0);
                                            } else {
                                                ctx.fillStyle = finalFillColor;
                                                ctx.fillText(rubyText[i], 0, 0);
                                            }
                                            ctx.restore();
                                        }
                                    } else {
                                        // æŒ¤å‹æ¨¡å¼
                                        const centerY = currentY + (tokenTotalHeight / 2);
                                        const scale = (tokenTotalHeight * 1.2) / rubyRawHeight; 
                                        const scaledFontSize = rubyFontSize * scale;
                                        const startY = centerY - (rubyRawHeight*scale / 2) + (scaledFontSize / 2);
                                        for (let i = 0; i < rubyCount; i++) {
                                            const rY = startY + (i * scaledFontSize);
                                            ctx.save(); ctx.translate(rubyX, rY); ctx.scale(1, scale); 
                                            if (style.rotation) ctx.rotate(style.rotation * Math.PI / 180);
                                            if (isManualSkew) ctx.transform(1, 0, Math.tan(skewAngle * Math.PI / 180) * -1, 1, 0, 0);
                                            if (style.vShear) ctx.transform(1, Math.tan(style.vShear * Math.PI / 180) * -1, 0, 1, 0, 0);
                                            ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; 
                                            if (isStroke) {
                                                ctx.strokeStyle = finalStrokeColor;
                                                ctx.lineWidth = rubyFontSize * finalStrokeWidthRatio * (1/scale);
                                                ctx.strokeText(rubyText[i], 0, 0);
                                            } else {
                                                ctx.fillStyle = finalFillColor;
                                                ctx.fillText(rubyText[i], 0, 0);
                                            }
                                            ctx.restore();
                                        }
                                    }
                                    ctx.restore(); 
                                    // æ¢å¤æ­£æ–‡å­—ä½“
                                    ctx.font = `${style.italic===true?'italic ':''} ${style.bold ? 'bold' : effectiveWeight} ${fSize}px ${style.font || effectiveFont.replace(/"/g,'')}`;
                                }

                                // === 3. ç«–æ’æ­£æ–‡ç»˜åˆ¶å¾ªç¯ (å«è´´è¾¹å¯¹é½) ===
                                charHeights.forEach(item => {
                                    const char = item.char; 
                                    const charH = item.h; 
                                    
                                    // --- A. è´´è¾¹å¯¹é½è®¡ç®— (Alignment Logic) ---
                                    let charCenterY = currentY + charH / 2;
                                    const alignDist = (fSize - charH) / 2;

                                    if (CHARS_OPENING.includes(char) || CHARS_PUNCT.includes(char)) {
                                        // å‰æ‹¬å·/é€—å·/å¥å·ï¼šå‘ä¸Šè´´è¾¹ (è¿œç¦»ä¸‹æ–‡)
                                        charCenterY -= alignDist;
                                    } 
                                    else if (CHARS_CLOSING.includes(char)) {
                                        // åæ‹¬å·ï¼šå‘ä¸‹è´´è¾¹ (è¿œç¦»ä¸Šæ–‡)
                                        charCenterY += alignDist;
                                    }


                                    ctx.save(); 
                                    ctx.translate(x + (style.offX || 0), charCenterY + (style.offY || 0));
                                    
                                    // --- B.æ—‹è½¬å¤„ç† & C.å˜å½¢é€»è¾‘  (å«ä¿®å¤) ---
                                    const isRotatedLetter = ROTATED_LETTERS_NUMBERS.includes(char);
                                    const needsRotation = isRotatedLetter || CHARS_TO_ROTATE.includes(char) || item.isSymmetric;

                                    if (needsRotation) { 
                                        ctx.rotate(Math.PI / 2); 
                                        if (char === "ã€œ") ctx.scale(-1, 1); 
                                        
                                        // ã€æ ¸å¿ƒä¿®å¤ã€‘
                                        // 1. é€»è¾‘äº’æ¢ï¼šæ–œä½“å½±å“ Y(param2)ï¼Œå‚ç›´åˆ‡å˜å½±å“ X(param3)
                                        // 2. ç¬¦å·ä¿®æ­£ï¼šç”±äºåæ ‡è½´æ—‹è½¬äº†90åº¦ï¼Œæ–¹å‘ä¹Ÿåäº†ï¼Œæ‰€ä»¥è¿™é‡ŒæŠŠåŸæœ¬çš„ * -1 å»æ‰
                                        
                                        // 1. æ–œä½“ (SkewX -> SkewY slot)
                                        // [i=15] åŸæœ¬æœ‰ *-1ï¼Œè¿™é‡Œå»æ‰ï¼Œå˜æˆæ­£åˆ‡å€¼
                                        if (isManualSkew) {
                                            ctx.transform(1, Math.tan(skewAngle * Math.PI / 180), 0, 1, 0, 0);
                                        }
                                        
                                        // 2. å‚ç›´åˆ‡å˜ (SkewY -> SkewX slot)
                                        // [v=15] åŸæœ¬æœ‰ *-1ï¼Œè¿™é‡Œå»æ‰ï¼Œå˜æˆæ­£åˆ‡å€¼
                                        if (style.vShear) {
                                            ctx.transform(1, 0, Math.tan(style.vShear * Math.PI / 180), 1, 0, 0);
                                        }

                                    } else {
                                        // ã€æ­£å¸¸å­—ç¬¦ã€‘æœªæ—‹è½¬ï¼Œä½¿ç”¨æ ‡å‡†é€»è¾‘
                                        
                                        // 1. æ­£å¸¸å˜å½¢ (åŸæ‰‹åŠ¨æ–œä½“ä»£ç )
                                        if (isManualSkew) {
                                            ctx.transform(1, 0, Math.tan(skewAngle * Math.PI / 180) * -1, 1, 0, 0);
                                        }
                                        
                                        // 2. æ­£å¸¸å‚ç›´åˆ‡å˜ (åŸå‚ç›´åˆ‡å˜ä»£ç )
                                        if (style.vShear) {
                                            ctx.transform(1, Math.tan(style.vShear * Math.PI / 180) * -1, 0, 1, 0, 0);
                                        }
                                    }

                                    // æ—‹è½¬é€»è¾‘ (rotation) ä¿æŒåœ¨æœ€åï¼Œå› ä¸ºå®ƒæ˜¯åœ¨è‡ªèº«åæ ‡ç³»æ—‹è½¬ï¼Œé€šå¸¸ä¸å—å½±å“ï¼Œ
                                    // ä½†ä¸ºäº†ä¿é™©ï¼Œé€šå¸¸æ”¾åœ¨åˆ‡å˜ä¹‹åæˆ–è€…ä¿æŒç°çŠ¶ã€‚
                                    if (style.rotation) ctx.rotate(style.rotation * Math.PI / 180);
                                    
                                    // é•œåƒå¤„ç†é€»è¾‘
                                    if (style.mirror) {
                                        ctx.scale(-1, 1);  // æ°´å¹³é•œåƒç¿»è½¬ [m]
                                    }
                                    if (style.mirrorV) {
                                        ctx.scale(1, -1);  // ç«–å‘é•œåƒç¿»è½¬ [mv]
                                    }

                                    ctx.textAlign = 'center'; 
                                    ctx.textBaseline = 'middle';

                                    // --- D. å¢¨è¿¹æ°´å¹³å±…ä¸­ (ä¼˜åŒ–ç‰ˆ) ---
                                    if (needsRotation && (CHARS_DYNAMIC_CENTER.includes(char) || item.isSymmetric) && !CHARS_NO_CENTER_H.includes(char)) {
                                        const metrics = ctx.measureText(char);
                                        
                                        // é‡‡ç”¨æ›´ç²¾ç¡®çš„å¢¨è¿¹å‡ ä½•ä¸­å¿ƒ
                                        // Ascent æ˜¯åŸºçº¿åˆ°å¢¨è¿¹é¡¶éƒ¨çš„è·ç¦»ï¼ŒDescent æ˜¯åŸºçº¿åˆ°å¢¨è¿¹åº•éƒ¨çš„è·ç¦»ï¼ˆé€šå¸¸ä¸ºè´Ÿï¼‰
                                        // æ—‹è½¬ 90 åº¦åï¼Œè¿™ä¸ªæ–¹å‘å˜æˆäº†æ°´å¹³æ–¹å‘çš„åç§»
                                        const inkMiddle = (metrics.actualBoundingBoxAscent - metrics.actualBoundingBoxDescent) / 2;
                                        
                                        // ä¿®æ­£ï¼šå¦‚æœå‘ç°æŸäº›ç¬¦å·ï¼ˆå¦‚ ã€‘ï¼‰ä¾ç„¶åç¦»ï¼Œå¯ä»¥ç»“åˆå­—å·è¿›è¡Œå¾®è°ƒ
                                        // å¤§å¤šæ•°æƒ…å†µä¸‹ï¼ŒinkMiddle å·²ç»èƒ½è§£å†³é—®é¢˜
                                        ctx.translate(0, inkMiddle);
                                    }

                                    // ç»˜åˆ¶åŸºå‡†ç‚¹
                                    let drawX = 0, drawY = 0;

                                    // --- E. éæ—‹è½¬æ ‡ç‚¹çš„å¾®è°ƒ (éåŠå®½) ---
                                    if (!needsRotation) {
                                        if (CHARS_UPRIGHT_CENTER.includes(char)) {
                                            const metrics = ctx.measureText(char);
                                            drawX = (metrics.actualBoundingBoxLeft - metrics.actualBoundingBoxRight) / 2;
                                            drawY = (metrics.actualBoundingBoxAscent - metrics.actualBoundingBoxDescent) / 2;
                                        }
                                        else if (CHARS_PUNCTUATION_TOP_RIGHT.includes(char)) { 
                                            // å¥è¯»ç‚¹å·²è¢«è´´è¾¹é€»è¾‘æ¥ç®¡ Y è½´ï¼Œè¿™é‡Œåªéœ€å¤„ç† X è½´åç§»
                                            drawX = fSize * 0.5; 
                                            drawY = 0; 
                                        } 
                                        else if (HALF_WIDTH_PUNCTUATION_TOP_RIGHT.includes(char)) { drawX = fSize * 0.3; drawY = -fSize * 0.4; }
                                        else if (CHARS_SMALL_KANA_TOP_RIGHT.includes(char)) { drawX = fSize * 0.1; drawY = -fSize * 0.15; }
                                    }

                                    // --- F. æœ€ç»ˆç»˜åˆ¶ (æè¾¹/å¡«å……/ç€é‡å·) ---

                                    // 1. [æ–°å¢] ç»Ÿä¸€è®¡ç®—ç€é‡å·çš„æ°´å¹³åç§»é‡
                                    let dotOffsetX = (fSize * 0.5) + (fSize * DOT_OFFSET_RATIO) + (fSize * DOT_RADIUS_RATIO);

                                    // 2. [å…³é”®é€»è¾‘]ï¼šåˆ©ç”¨é¢„è®¡ç®—çš„ lineLayouts[i].hasRuby åˆ¤æ–­æ•´è¡Œæ˜¯å¦éœ€è¦é¿è®©
                                    // åªè¦æœ¬è¡Œä¸­æœ‰ä¸€ä¸ªå­—æœ‰æ³¨éŸ³ï¼Œæ•´è¡Œçš„ç‚¹å…¨éƒ¨å‘å³å¹³ç§»
                                    if (lineLayouts[i] && lineLayouts[i].hasRuby) {
                                        dotOffsetX += (fSize * RUBY_SIZE_RATIO); 
                                    }

                                    const dotCenterX = drawX + dotOffsetX;

                                    if (isStroke) {
                                        if (useConcentricFill) {
                                            ctx.save();
                                            const maxW = fSize * finalStrokeWidthRatio;
                                            const step = Math.max(0.5, fSize * 0.05);
                                            for (let w = maxW; w > 0; w -= step) { ctx.lineWidth = w; ctx.strokeText(char, drawX, drawY); }
                                            ctx.fillText(char, drawX, drawY); 
                                            ctx.restore();
                                        } else {
                                            ctx.strokeText(char, drawX, drawY);
                                        }
                                        
                                        // ç»˜åˆ¶æè¾¹ç‰ˆç€é‡å·
                                        if (style.dot) {
                                            ctx.beginPath();
                                            ctx.arc(dotCenterX, drawY, fSize * DOT_RADIUS_RATIO, 0, Math.PI * 2);
                                            ctx.lineWidth = fSize * finalStrokeWidthRatio; 
                                            ctx.stroke();
                                        }
                                    } else if (isFill || isGlow) { 
                                        // å…³é”®ç‚¹ï¼šå‘å…‰å±‚ (isGlow) å¿…é¡»æ‰§è¡Œ fillTextï¼Œé˜´å½±æ‰ä¼šæ˜¾ç°
                                        ctx.fillText(char, drawX, drawY); 

                                        // åŒæ ·ï¼Œç€é‡å·ä¹Ÿéœ€è¦å¤„ç†
                                        if (style.dot) {
                                            ctx.beginPath();
                                            const dotY = drawY; // æ ¹æ®ä½ çš„é€»è¾‘è®¡ç®—
                                            ctx.arc(dotCenterX, dotY, fSize * DOT_RADIUS_RATIO, 0, Math.PI * 2);
                                            ctx.fill(); 
                                        }
                                    }
                                    
                                    ctx.restore(); 
                                    currentY += charH + item.spacing;
                                });
                            }
                        });
                    });

                } else {
                    // === æ¨ªæ’é€»è¾‘ (ä¿®å¤ç‰ˆï¼šå®ç°æ‹¬å·ç²¾å‡†è´´è¾¹ä¸å•æ¬¡å¾ªç¯æ¸²æŸ“) ===
                    let maxLineWidth = 0;
                    
                    // --- 1. é¢„è®¡ç®—è¡Œå®½ä¸å­—ç¬¦è¯¦æƒ… (ç”¨äºå¤„ç†å—å¯¹é½) ---
                    const linesWidths = processedLines.map(toks => {
                        let w = 0; 
                        toks.forEach(tok => {
                            const fSize = baseFontSize * (tok.style.scale || 1.0);
                            ctx.font = `${tok.style.italic===true?'italic ':''} ${tok.style.bold ? 'bold' : effectiveWeight} ${fSize}px ${tok.style.font || effectiveFont.replace(/"/g,'')}`;
                            
                            tok.charDetails = []; // æŒ‚è½½è¯¦æƒ…ä¾›æ¸²æŸ“ä½¿ç”¨

                            for (let i = 0; i < tok.text.length; i++) {
                                const char = tok.text[i]; 
                                const cW = ctx.measureText(char).width; 
                                const spacing = letterSpacingPx + (tok.style.kerning || 0) * fSize;
                                
                                let visualWidth, isSymmetric = false;

                                // åˆ¤å®šå¯¹ç§°æ ‡ç‚¹ (æ‹¬å·ç­‰)
                                if (CHARS_SYMMETRIC_HALF.includes(char) || CHARS_PUNCT.includes(char)) {
                                    isSymmetric = true;
                                    visualWidth = fSize * 0.5; // å¼ºåˆ¶å ç”¨åŠå®½æ ¼å­
                                } else if (CHARS_HORIZONTAL_COMPRESSION.includes(char)) {
                                    visualWidth = cW * 0.5; // æ™®é€šå‹ç¼©æ ‡ç‚¹
                                } else {
                                    visualWidth = cW; // æ™®é€šæ–‡å­—
                                }

                                const advance = visualWidth + spacing;
                                w += advance;

                                tok.charDetails.push({ 
                                    char, originalWidth: cW, visualWidth, advance, spacing, isSymmetric 
                                });
                            }
                            if (tok.charDetails.length > 0) w -= (letterSpacingPx + (tok.style.kerning || 0) * fSize);
                        });
                        if (w > maxLineWidth) maxLineWidth = w; 
                        return w;
                    });

                    // --- 2. æ ¸å¿ƒæ¸²æŸ“å¾ªç¯ ---
                    processedLines.forEach((tokens, lineIndex) => {
                        const lineWidth = linesWidths[lineIndex];
                        const y = linePositions[lineIndex];
                        
                        let currentX;
                        // å¤„ç†å¯¹é½æ–¹å¼
                        if (effectiveAlign === 'block-center-top') currentX = -maxLineWidth / 2;
                        else if (effectiveAlign === 'block-top') currentX = -boxWidth / 2;
                        else if (effectiveAlign === 'block-bottom') currentX = (boxWidth / 2) - lineWidth;
                        else currentX = -lineWidth / 2;

                        tokens.forEach(tok => {
                            const style = tok.style; 
                            const fSize = baseFontSize * (style.scale || 1.0);
                            const isManualSkew = (typeof style.italic === 'number'); 
                            const skewAngle = isManualSkew ? style.italic : 0;
                            
                            ctx.font = `${style.italic===true?'italic ':''} ${style.bold ? 'bold' : effectiveWeight} ${fSize}px ${style.font || effectiveFont.replace(/"/g,'')}`;
                            ctx.lineWidth = fSize * finalStrokeWidthRatio;

                            // === [æ–°å¢] æ¨ªæ’ Ruby ç»˜åˆ¶é€»è¾‘ ===
                            if (style.ruby) {
                                ctx.save();
                                const rubyFontSize = fSize * RUBY_SIZE_RATIO;
                                const rubyFont = `${style.bold ? 'bold' : ''} ${rubyFontSize}px ${style.font || effectiveFont.replace(/"/g,'')}`;
                                ctx.font = rubyFont;

                                const rubyText = style.ruby;
                                const rubyCount = rubyText.length;
                                
                                // è®¡ç®—è¿™ä¸ª Token çš„æ€»å®½åº¦ä»¥ä¾¿å¹³åˆ† Ruby
                                let tokenWidth = 0;
                                if (tok.charDetails) {
                                    tok.charDetails.forEach(cd => tokenWidth += cd.advance);
                                }

                                // è®¡ç®— Ruby çš„ Y è½´ä½ç½®ï¼ˆåœ¨æ­£æ–‡ä¸Šæ–¹ï¼‰
                                const rubyY = y - (fSize * 0.5) - (rubyFontSize * 0.5) - (fSize * RUBY_OFFSET_RATIO);

                                for (let rIdx = 0; rIdx < rubyCount; rIdx++) {
                                    // åœ¨ Token å®½åº¦å†…å‡åŒ€åˆ†å¸ƒ Ruby å­—ç¬¦
                                    const rubyX = currentX + (tokenWidth / rubyCount) * (rIdx + 0.5);
                                    
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';

                                    if (isStroke) {
                                        ctx.strokeStyle = finalStrokeColor;
                                        ctx.lineWidth = rubyFontSize * finalStrokeWidthRatio;
                                        ctx.strokeText(rubyText[rIdx], rubyX, rubyY);
                                    } else {
                                        ctx.fillStyle = finalFillColor;
                                        ctx.fillText(rubyText[rIdx], rubyX, rubyY);
                                    }
                                }
                                ctx.restore();
                                // æ¢å¤æ­£æ–‡å­—ä½“è®¾ç½®ï¼Œé˜²æ­¢å½±å“åç»­å­—ç¬¦
                                ctx.font = `${style.italic===true?'italic ':''} ${style.bold ? 'bold' : effectiveWeight} ${fSize}px ${style.font || effectiveFont.replace(/"/g,'')}`;
                            }

                            // æ¸²æŸ“å­—ç¬¦
                            if (tok.charDetails) {
                                tok.charDetails.forEach(item => {
                                    const char = item.char;
                                    const slotWidth = item.visualWidth;

                                    let drawCenterX = currentX + slotWidth / 2; 

                                    if (item.isSymmetric) {
                                        const alignDist = (fSize - slotWidth) / 2;
                                        // ä½¿ç”¨ä½ å®šä¹‰çš„å¸¸é‡ï¼Œä¿æŒå…¨å±€ç»Ÿä¸€
                                        const isPunctuation = CHARS_PUNCT.includes(char);
                                        const isOpening = CHARS_OPENING.includes(char);
                                        const isClosing = CHARS_CLOSING.includes(char);

                                        // å¥å·ã€é€—å·ã€åæ‹¬å·ï¼šå‘å³æ¨ (+=)ï¼Œç´§è´´å·¦ä¾§æ–‡å­—
                                        if (isPunctuation || isClosing) {
                                            drawCenterX += alignDist; 
                                        }
                                        // å‰æ‹¬å·ï¼šå‘å·¦æ‹‰ (-=)ï¼Œç´§è´´å³ä¾§æ–‡å­—
                                        else if (isOpening) {
                                            drawCenterX -= alignDist;
                                        }
                                    }
                                    ctx.save();
                                    ctx.translate(drawCenterX + (style.offX || 0), y + (style.offY || 0));
                                    
                                    // é•œåƒå¤„ç†é€»è¾‘
                                    if (style.mirror) {
                                        ctx.scale(-1, 1);  // æ°´å¹³é•œåƒç¿»è½¬ [m]
                                    }
                                    if (style.mirrorV) {
                                        ctx.scale(1, -1);  // ç«–å‘é•œåƒç¿»è½¬ [mv]
                                    }
                                    
                                    if (char === "ã€œ") ctx.scale(-1, 1);
                                    if (isManualSkew) ctx.transform(1, 0, Math.tan(skewAngle * Math.PI / 180) * -1, 1, 0, 0);
                                    if (style.rotation) ctx.rotate(style.rotation * Math.PI / 180);
                                    
                                    ctx.textAlign = 'center'; 
                                    ctx.textBaseline = 'middle';

                                    if (isStroke) {
                                        if (useConcentricFill) {
                                            const maxW = fSize * finalStrokeWidthRatio;
                                            for (let w = maxW; w > 0; w -= Math.max(0.5, fSize * 0.05)) { 
                                                ctx.lineWidth = w; ctx.strokeText(char, 0, 0); 
                                            }
                                            ctx.fillText(char, 0, 0);
                                        } else {
                                            ctx.strokeText(char, 0, 0);
                                        }
                                        if (style.dot) { // ç€é‡å·
                                            ctx.beginPath();
                                            const dotY = (fSize * 0.5) + (fSize * DOT_OFFSET_RATIO) + (fSize * DOT_RADIUS_RATIO);
                                            ctx.arc(0, dotY, fSize * DOT_RADIUS_RATIO, 0, Math.PI * 2);
                                            ctx.lineWidth = fSize * finalStrokeWidthRatio; ctx.stroke();
                                        }
                                    } else if (isFill || isGlow) {
                                        // å‘å…‰å±‚å’Œå¡«å……å±‚éƒ½è°ƒç”¨ fillText
                                        ctx.fillText(char, 0, 0);

                                        if (style.dot) {
                                            ctx.beginPath();
                                            const dotY = (fSize * 0.5) + (fSize * DOT_OFFSET_RATIO) + (fSize * DOT_RADIUS_RATIO);
                                            ctx.arc(0, dotY, fSize * DOT_RADIUS_RATIO, 0, Math.PI * 2);
                                            ctx.fill(); 
                                        }
                                    }
                                    ctx.restore();
                                    currentX += item.advance;
                                });
                            }
                        });
                    });
                }
                ctx.restore();
            }

            // ä¿®æ”¹å‰ï¼š
            // if (!onlyPass || onlyPass === 'stroke') renderPass('stroke');
            // if (!onlyPass || onlyPass === 'fill') renderPass('fill');

            // ä¿®æ”¹åï¼šä¸¥æ ¼çš„æ±‰å ¡åŒ…å åŠ é¡ºåº
            if (!onlyPass) {
                renderPass('glow');   // æœ€åº•å±‚ï¼šå‘å…‰
                renderPass('stroke'); // ä¸­é—´å±‚ï¼šæè¾¹
                renderPass('fill');   // æœ€ä¸Šå±‚ï¼šå¡«å……ï¼ˆç¡®ä¿æ–‡å­—æ¸…æ™°ï¼‰
            } else {
                renderPass(onlyPass);
            }
            
            ctx.restore();
        }

        // [Original Mode Strict Line] - (No changes needed here)
        // [é‡å†™] åŸæ–‡æ¨¡å¼æ¸²æŸ“å‡½æ•° - è§£å†³äº†æ ‡ç‚¹é‡å ä¸å±…ä¸­é—®é¢˜
        // --- [ä¿®æ­£ç‰ˆ] åŸæ–‡æ¨¡å¼æ¸²æŸ“ï¼šåŒæ­¥æ ‡ç‚¹å‹ç¼©ä¸æ—‹è½¬é€»è¾‘ ---
        // --- [æ ¸å¿ƒå‡çº§] åŸæ–‡æ¨¡å¼ï¼šå…¨é¢åŒæ­¥è¯‘æ–‡æ¨¡å¼çš„å‹ç¼©ä¸å±…ä¸­ç®—æ³• ---
        // --- [ç»ˆæä¿®æ­£] åŸæ–‡æ¨¡å¼ï¼šå…¨é¢åŒæ­¥è¯‘æ–‡æ¨¡å¼çš„å‹ç¼©ã€è´´è¾¹ä¸å‡ ä½•ä¸­å¿ƒå±…ä¸­ç®—æ³• ---
        // --- [ç»ˆæä¿®æ­£] åŸæ–‡æ¨¡å¼ï¼šå…¨é¢åŒæ­¥è¯‘æ–‡æ¨¡å¼çš„å‹ç¼©ã€è´´è¾¹ä¸å‡ ä½•ä¸­å¿ƒå±…ä¸­ç®—æ³• ---
        // --- [ç»ˆæä¿®æ­£] ç›´æ¥å¼•ç”¨ CHARS_DYNAMIC_CENTER å¸¸é‡ï¼Œä¸¥æ ¼å¯¹é½è¯‘æ–‡æ¨¡å¼ç®—æ³• ---
        // --- [ç»ˆæä¿®æ­£] 1:1 å¤åˆ»è¯‘æ–‡æ¨¡å¼æ¸²æŸ“æµæ°´çº¿ ---
        function drawOriginal(r) {
            if (!r.lines || !r.texts) return;
            const fs = r.font_size || 20;
            const isVertical = r.direction === 'v';
            const tcyEnabled = (r.tcy_enabled !== undefined) ? r.tcy_enabled : true;

            ctx.save();
            ctx.fillStyle = "black";
            ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
            ctx.lineWidth = 2 / viewState.scale;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            r.lines.forEach((polygon, i) => {
                const text = r.texts[i] || "";
                if (!text) return;

                const center = getPolygonCenter(polygon);
                const p0 = polygon[0], p1 = polygon[1];
                let angle = Math.atan2(p1[1] - p0[1], p1[0] - p0[0]);
                let angleDeg = angle * 180 / Math.PI;
                if (angleDeg > 90) angleDeg -= 180;
                if (angleDeg < -90) angleDeg += 180;
                angle = angleDeg * Math.PI / 180;

                ctx.save();
                ctx.translate(center.x, center.y);
                ctx.rotate(angle);
                ctx.font = `${fs}px "Noto Sans JP", sans-serif`;

                if (isVertical) {
                    // --- 1. ç«–æ’é€»è¾‘ ---
                    const segments = [];
                    if (tcyEnabled) {
                        const regex = /([\d\uFF10-\uFF19]{2,4})/g;
                        let match, lastIdx = 0;
                        while ((match = regex.exec(text)) !== null) {
                            if (match.index > lastIdx) segments.push({ text: text.substring(lastIdx, match.index), tcy: false });
                            segments.push({ text: match[0], tcy: true });
                            lastIdx = regex.lastIndex;
                        }
                        if (lastIdx < text.length) segments.push({ text: text.substring(lastIdx), tcy: false });
                    } else { segments.push({ text: text, tcy: false }); }

                    // è®¡ç®—æ€»é«˜åº¦ (å¿…é¡»ä¸æ¸²æŸ“æ­¥è¿› 100% åŒæ­¥)
                    let totalH = 0;
                    segments.forEach(seg => {
                        if (seg.tcy) totalH += fs;
                        else {
                            for (const char of seg.text) {
                                const m = ctx.measureText(char);
                                const isRot = ROTATED_LETTERS_NUMBERS.includes(char) || CHARS_TO_ROTATE.includes(char);
                                const isComp = CHARS_VERTICAL_COMPRESSION.includes(char) || CHARS_SYMMETRIC_HALF.includes(char) || isHalfWidth(char);
                                // å‹ç¼©ç¬¦ 0.5fsï¼Œæ—‹è½¬å­—æ¯å–å®½åº¦ï¼Œå…¶ä»–å– fs
                                totalH += isComp ? (fs * 0.5) : (isRot ? (ROTATED_LETTERS_NUMBERS.includes(char) ? m.width : fs) : fs);
                            }
                        }
                    });

                    let currentY = -totalH / 2;
                    segments.forEach(seg => {
                        if (seg.tcy) {
                            ctx.save(); ctx.translate(0, currentY + fs / 2); ctx.strokeText(seg.text, 0, 0); ctx.fillText(seg.text, 0, 0); ctx.restore();
                            currentY += fs;
                        } else {
                            for (const char of seg.text) {
                                const m = ctx.measureText(char);
                                const isRot = ROTATED_LETTERS_NUMBERS.includes(char) || CHARS_TO_ROTATE.includes(char);
                                const isComp = CHARS_VERTICAL_COMPRESSION.includes(char) || CHARS_SYMMETRIC_HALF.includes(char) || isHalfWidth(char);
                                const stepH = isComp ? (fs * 0.5) : (isRot ? (ROTATED_LETTERS_NUMBERS.includes(char) ? m.width : fs) : fs);

                                // A. å‚ç›´ä½ç½® (è´´è¾¹é€»è¾‘)
                                let charY = currentY + stepH / 2;
                                const alignDist = (fs - stepH) / 2;
                                if (CHARS_OPENING.includes(char) || CHARS_PUNCT.includes(char)) charY -= alignDist;
                                else if (CHARS_CLOSING.includes(char)) charY += alignDist;

                                // B. å±…ä¸­è®¡ç®— (inkMiddle)
                                let inkOffset = 0;
                                if (CHARS_DYNAMIC_CENTER.includes(char)) {
                                    // å¯¹äºæ—‹è½¬äº†90åº¦çš„å­—ç¬¦ï¼Œé«˜åº¦æŒ‡æ ‡(Ascent/Descent)å˜æˆäº†æ°´å¹³æ–¹å‘çš„åç§»æŒ‡æ ‡
                                    inkOffset = (m.actualBoundingBoxAscent - m.actualBoundingBoxDescent) / 2;
                                } 
                                else if (CHARS_VISUAL_CENTER.includes(char)) {
                                    inkOffset = (m.actualBoundingBoxLeft - m.actualBoundingBoxRight) / 2; // ä¿®æ”¹ä¸ºç›¸å‡
                                }

                                ctx.save();
                                if (isRot) {
                                    // ã€å¤åˆ»è¯‘æ–‡æ¨¡å¼æ ¸å¿ƒæ­¥éª¤ã€‘
                                    ctx.translate(0, charY);     // å…ˆç§»åˆ°è¡Œçš„ä¸­è½´çº¿å’Œå­—ç¬¦é«˜åº¦ä¸­å¿ƒ
                                    ctx.rotate(Math.PI / 2);    // æ—‹è½¬ 90 åº¦
                                    if (char === "ã€œ") ctx.scale(-1, 1);
                                    // é‡ç‚¹ï¼šinkOffset å¿…é¡»åŠ åœ¨ç¬¬äºŒä¸ªå‚æ•° (æ¸²æŸ“åæ ‡çš„ Y)
                                    // åœ¨æ—‹è½¬åçš„åæ ‡ç³»é‡Œï¼Œè¿™æ‰æ˜¯è§†è§‰ä¸Šçš„â€œå·¦å³æ°´å¹³ç§»åŠ¨â€
                                    ctx.strokeText(char, 0, inkOffset);
                                    ctx.fillText(char, 0, inkOffset);
                                } else {
                                    ctx.translate(inkOffset, charY);
                                    ctx.strokeText(char, 0, 0);
                                    ctx.fillText(char, 0, 0);
                                }
                                ctx.restore();
                                currentY += stepH;
                            }
                        }
                    });

                } else {
                    // --- 2. æ¨ªæ’é€»è¾‘ (å¯¹é½è¯‘æ–‡æ¨¡å¼å‹ç¼©) ---
                    let totalW = 0;
                    const charDetails = [];
                    for (const char of text) {
                        const m = ctx.measureText(char);
                        const isComp = CHARS_HORIZONTAL_COMPRESSION.includes(char) || CHARS_SYMMETRIC_HALF.includes(char);
                        const vW = isComp ? m.width * 0.5 : m.width;
                        totalW += vW;
                        charDetails.push({ char, m, vW });
                    }
                    let currentX = -totalW / 2;
                    charDetails.forEach(item => {
                        const { char, m, vW } = item;
                        let dX = currentX + vW / 2;
                        const aDist = (m.width - vW) / 2;
                        if (CHARS_PUNCT.includes(char) || CHARS_CLOSING.includes(char)) dX += aDist;
                        else if (CHARS_OPENING.includes(char)) dX -= aDist;
                        ctx.save(); ctx.translate(dX, 0); if (char === "ã€œ") ctx.scale(-1, 1);
                        ctx.strokeText(char, 0, 0); ctx.fillText(char, 0, 0); ctx.restore();
                        currentX += vW;
                    });
                }
                ctx.restore();
            });
            ctx.restore();
        }
        // --- Utils ---
        // --- [ç»‘å®šäº‹ä»¶] ---
        document.getElementById('repairInput').addEventListener('change', (e) => handleImageUpload(e, 'repair'));
        document.getElementById('repairFolderInput').addEventListener('change', (e) => handleFolderSelect(e, 'repair'));


        // --- [ä¿®æ”¹] handleImageUpload æ”¯æŒä¿®å¤å›¾ ---
        function handleImageUpload(e, type = 'original') {
            const file = e.target.files[0];
            if (!file) return;
            const img = new Image();
            img.onload = () => {
                if (type === 'repair') {
                    currentRepairImage = img;
                } else {
                    currentImage = img;
                    currentFileName = file.name.split('.')[0];
                }
                resizeCanvas();
                draw();
            };
            img.src = URL.createObjectURL(file);
        }

        // --- [ä¿®æ”¹] æ‰¹é‡åŒ¹é…é€»è¾‘ (matchAndLoadFiles) ---
        // åœ¨ tempMatches.push æ—¶åŠ å…¥ repairImage åŒ¹é…ï¼Œé€šå¸¸æ ¹æ®æ–‡ä»¶åç›¸åŒæ¥åŒ¹é…
        // ä¾‹å¦‚ï¼š001.jpg (åŸå›¾) -> 001.png (ä¿®å¤å›¾)

        function resizeCanvas() {
            if(!currentImage) return;
            mainCanvas.width = currentImage.width; 
            mainCanvas.height = currentImage.height;
            
            const container = document.getElementById('canvasContainer');
            const rect = container.getBoundingClientRect();
            
            // é¢„ç•™ 40px çš„è§†è§‰è¾¹è·ï¼Œä¸è®©å›¾ç‰‡è´´è¾¹å¤ªæ­»
            const padding = 40; 
            const availableW = rect.width - padding;
            const availableH = rect.height - padding;

            const scaleX = availableW / currentImage.width;
            const scaleY = availableH / currentImage.height;
            
            // [ä¿®æ”¹] å–æ¶ˆ Math.min(..., 1)ï¼Œå…è®¸è‡ªåŠ¨æ”¾å¤§é€‚åº”å±å¹•
            // è¿™æ ·å›¾ç‰‡ä¸€å¼€å§‹å°±ä¼šå°½å¯èƒ½å¤§ï¼ˆé€‚åº”çª—å£ï¼‰
            const initScale = Math.min(scaleX, scaleY) * 0.95; 
            
            viewState.scale = initScale;
            // å±…ä¸­è®¡ç®—
            viewState.x = (rect.width - currentImage.width * initScale) / 2;
            viewState.y = (rect.height - currentImage.height * initScale) / 2;
            
            updateCanvasTransform();
        }
        function exportImage() {
            if(!currentImage) return alert("æ— å›¾ç‰‡");
            const link = document.createElement('a'); link.download = `${currentFileName}_exported.png`;
            link.href = mainCanvas.toDataURL(); link.click();
        }
        function updateActiveRegionProp(prop, value) {
            if(activeRegionIndex !== -1 && regions[activeRegionIndex]) { regions[activeRegionIndex][prop] = value; draw(); }
        }

        function renderSidebar() {
            sidebarList.innerHTML = '';
            regions.forEach((r, i) => {
                const div = document.createElement('div');
                div.id = `sb-${i}`;
                div.className = `sidebar-item p-2 rounded cursor-pointer mb-1 border border-gray-700 bg-gray-800 ${i===activeRegionIndex?'active':''}`;
                const dirLabel = r.direction === 'v' ? 'ç«–' : 'æ¨ª';
                const angleLabel = Math.round(r.angle || 0);
                div.innerHTML = `
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-xs font-mono font-bold text-yellow-500">#${i + 1}</span>
                        <div class="flex gap-1">
                            <span class="text-[9px] px-1.5 py-0.5 rounded bg-gray-700 text-gray-300 font-size-tag">Sz:${Math.round(r.font_size || 20)}</span>
                            <span class="text-[9px] px-1.5 py-0.5 rounded bg-purple-900 text-purple-200">A:${angleLabel}Â°</span>
                            <span class="text-[9px] px-1.5 py-0.5 rounded ${r.direction === 'v' ? 'bg-blue-600 text-white' : 'bg-gray-600 text-gray-300'}">${dirLabel}</span>
                        </div>
                    </div>
                    <div class="text-sm text-green-400 font-bold leading-snug line-clamp-2">${(r.translation||"").replace(/ã€BRã€‘/g, ' ')}</div>
                `;
                div.onclick = () => { setActiveRegion(i); };
                div.ondblclick = () => { setActiveRegion(i); openTextEditor(); };
                sidebarList.appendChild(div);
            });
        }
        function updateSidebarItem(i) { if(document.getElementById(`sb-${i}`)) renderSidebar(); }


        


        
        function handleFolderSelect(e, type) {
            const allFiles = Array.from(e.target.files);
            // ã€è¿‡æ»¤ã€‘åªä¿ç•™æ ¹ç›®å½•æ–‡ä»¶ï¼Œé˜²æ­¢ç»Ÿè®¡æ•°å­—çˆ†ç‚¸
            const rootFiles = allFiles.filter(f => f.webkitRelativePath.split('/').length === 2);

            if (type === 'image') imageFiles = rootFiles;
            else if (type === 'json') jsonFiles = rootFiles;
            else if (type === 'repair') repairFiles = rootFiles; // æ–°å¢ä¿®å¤å›¾æ”¯æŒ
            
            matchAndLoadFiles();
        }

        // åŒæ—¶ä¿®æ”¹ HTML ç›‘å¬ç»‘å®š (çº¦ 982 è¡Œé™„è¿‘)
        imageFolderInput.addEventListener('change', (e) => handleFolderSelect(e, 'image'));
        jsonFolderInput.addEventListener('change', (e) => handleFolderSelect(e, 'json'));
        // ä¿®æ”¹çº¦ 1550 è¡Œçš„ç»‘å®š
        
        // --- [ä¿®æ­£] é€‚é… MTU å‘½åè§„èŒƒçš„åŒ¹é…é€»è¾‘ ---
        // --- [ä¼˜åŒ–] æ‰¹é‡åŒ¹é…é€»è¾‘ ---
        async function matchAndLoadFiles() {
            if (!imageFiles || !jsonFiles) return;
            
            // --- å†…éƒ¨è¾…åŠ©å‡½æ•°ï¼šå½’ä¸€åŒ–å¤„ç† ---
            // ä¾‹å¦‚æŠŠ "0329_left_inpainted.jpg" å’Œ "0329_left.jpg" éƒ½å˜æˆ "0329_left"
            const getCleanKey = (name) => {
                return name.toLowerCase()
                    .split('.')[0]
                    .replace('_translations', '')
                    .replace('_inpainted', '')
                    .replace('_fixed', '')
                    .replace('_mask', '')
                    .trim();
            };

            // 1. æ‰«æä¿®å¤å›¾å’Œ JSONï¼Œå»ºç«‹å¿«é€Ÿç´¢å¼•å­—å…¸
            const repairMap = new Map();
            if (repairFiles) {
                repairFiles.forEach(f => {
                    repairMap.set(getCleanKey(f.name), f);
                });
            }

            const jsonMap = new Map();
            jsonFiles.forEach(f => {
                jsonMap.set(getCleanKey(f.name), f);
            });

            const tempMatches = [];

            // 2. ä»¥åŸå›¾åˆ—è¡¨ä¸ºåŸºå‡†è¿›è¡Œâ€œè¿è¿çœ‹â€
            for (const imgFile of imageFiles) {
                const imgKey = getCleanKey(imgFile.name);
                
                // åªè¦èƒ½æ‰¾åˆ°å¯¹åº”çš„ JSONï¼Œå°±è®¤ä¸ºè¿™ä¸€é¡µæœ‰æ•ˆ
                if (jsonMap.has(imgKey)) {
                    const jsonFile = jsonMap.get(imgKey);
                    try {
                        const jsonText = await jsonFile.text();
                        const raw = JSON.parse(jsonText);
                        const data = raw.regions ? raw : raw[Object.keys(raw)[0]];
                        
                        tempMatches.push({ 
                            image: imgFile, 
                            // æ— è®º LaMa ç»™ä½ çš„å›¾åŠ äº†ä»€ä¹ˆåç¼€ï¼Œè¿™é‡Œéƒ½èƒ½è‡ªåŠ¨å‹¾æ­ä¸Š
                            repairImage: repairMap.get(imgKey) || null, 
                            jsonName: jsonFile.name, 
                            regions: data.regions || [] 
                        });
                    } catch (err) {
                        console.error("JSON è§£æå¤±è´¥:", jsonFile.name, err);
                    }
                }
            }

            // 3. ã€æ ¸å¿ƒä¿è¯ã€‘æ‰§è¡Œè‡ªç„¶æ•°æ’åºï¼Œé˜²æ­¢ 10.jpg æ’åœ¨ 2.jpg å‰é¢
            matchedFiles = tempMatches.sort((a, b) => 
                a.image.name.localeCompare(b.image.name, undefined, { numeric: true, sensitivity: 'base' })
            );

            // 4. UI åé¦ˆ
            if (matchedFiles.length > 0) {
                currentFileIndex = 0;
                batchNav.classList.replace('hidden', 'flex');
                loadFile(0);
                console.log(`æˆåŠŸåŒ¹é… ${matchedFiles.length} ç»„æ–‡ä»¶ï¼Œä¿®å¤å›¾åŒ¹é…æˆåŠŸç‡å·²æå‡ã€‚`);
            } else {
                alert("æœªå‘ç°åŒ¹é…çš„ JSON æ–‡ä»¶ï¼è¯·æ£€æŸ¥åŸå›¾å’Œ JSON æ˜¯å¦åœ¨å‰ç¼€ä¸Šä¿æŒä¸€è‡´ã€‚");
            }
        }

        // --- [æ–°å¢] è·³è½¬åˆ°æŒ‡å®šç´¢å¼• (å«ä¿å­˜é€»è¾‘) ---
        function jumpToPage(index) {
            if (index < 0 || index >= matchedFiles.length) return;
            // ç¦»å¼€å‰ä¿å­˜å½“å‰é¡µä¿®æ”¹
            if (matchedFiles[currentFileIndex]) {
                matchedFiles[currentFileIndex].regions = JSON.parse(JSON.stringify(regions));
            }
            currentFileIndex = index;
            loadFile(currentFileIndex);
        }

        // --- [æ–°å¢] åˆ·æ–°å¯¼èˆªæŒ‰é’®çš„ç¦ç”¨çŠ¶æ€ (å˜ç°é€»è¾‘) ---
        function updateBatchNavUI() {
            const isFirst = currentFileIndex === 0;
            const isLast = currentFileIndex === matchedFiles.length - 1;
            
            // å¤„äºç¬¬ä¸€é¡µæ—¶ï¼Œç¦ç”¨â€œé¦–é¡µâ€å’Œâ€œä¸Šä¸€é¡µâ€
            document.getElementById('btnFirstPage').disabled = isFirst;
            document.getElementById('btnPrevPage').disabled = isFirst;
            
            // å¤„äºæœ«é¡µæ—¶ï¼Œç¦ç”¨â€œæœ«é¡µâ€å’Œâ€œä¸‹ä¸€é¡µâ€
            document.getElementById('btnLastPage').disabled = isLast;
            document.getElementById('btnNextPage').disabled = isLast;
        }

        // --- [æ–°å¢] è·³é¡µç›‘å¬é€»è¾‘ ---
        // --- [å®Œå–„] ç›‘å¬é¡µç è¾“å…¥æ¡†çš„å›è½¦è·³è½¬ ---
        pageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const val = parseInt(pageInput.value);
                if (!isNaN(val) && val >= 1 && val <= matchedFiles.length) {
                    jumpToPage(val - 1);
                    pageInput.blur(); 
                } else {
                    alert(`è¯·è¾“å…¥ 1-${matchedFiles.length} ä¹‹é—´çš„é¡µç `);
                    pageInput.value = currentFileIndex + 1;
                }
            }
        });
        // --- [ä¿®æ­£] æ‰¹é‡åŠ è½½å‡½æ•°ï¼šä¸¥æ ¼å¯¹é½å•é¡µ handleJsonUpload çš„åˆå§‹åŒ–é€»è¾‘ ---
        async function loadFile(index) {
            if (index < 0 || index >= matchedFiles.length) return;
            const item = matchedFiles[index];
            
            // 1. åŒæ­¥ UI é¡µç æ˜¾ç¤º
            pageInput.value = index + 1;
            fileCounterTotal.textContent = `/ ${matchedFiles.length}`;

            const img = new Image();
            img.onload = () => {
                currentImage = img;
                currentFileName = item.image.name.split('.')[0];

                // --- ã€æ–°å¢ï¼šåŠ è½½ä¿®å¤å›¾ã€‘ ---
                if (item.repairImage) {
                    const rImg = new Image();
                    rImg.onload = () => {
                        currentRepairImage = rImg;
                        draw(); // ä¿®å¤å›¾åŠ è½½å®Œåå†ç”»ä¸€æ¬¡
                    };
                    rImg.src = URL.createObjectURL(item.repairImage);
                } else {
                    currentRepairImage = null; // æ²¡ä¿®å¤å›¾å°±æ¸…ç©º
                }
                
                // 2. åŠ è½½æ•°æ®ï¼šç›´æ¥æ²¿ç”¨ handleJsonUpload çš„åˆå§‹åŒ–è¿‡ç¨‹
                // æ³¨æ„ï¼šè¿™é‡Œè¦ç”¨æ·±æ‹·è´ï¼Œé˜²æ­¢æ±¡æŸ“ matchedFiles åŸå§‹æ•°æ®
                regions = JSON.parse(JSON.stringify(item.regions)); 
                
                regions.forEach(r => {
                    // --- ä»¥ä¸‹éƒ¨åˆ†å®Œå…¨å¤åˆ»è‡ª handleJsonUpload çš„ regions.forEach å¾ªç¯ ---
                    if (r.direction === 'v') r.line_spacing = 1.2; else r.line_spacing = 1.2;
                    if (r.fg_colors) r.parsedColor = parseColor(r.fg_colors);

                    // --- [æ–°å¢] æ‰¹é‡åŠ è½½æ—¶è‡ªåŠ¨æ£€æµ‹ç™½è‰² ---
                    if (r.parsedColor) {
                        const hex = colorToHex(r.parsedColor);
                        if (isNearWhite(hex)) {
                            if (!r.strokeColor) {
                                r.strokeColor = "#000000";
                                if (r.strokeWidthRatio === undefined || r.strokeWidthRatio === 0) {
                                    r.strokeWidthRatio = 0.2;
                                }
                            }
                        }
                    }
                    
                    if (!r.strokeColor) r.strokeColor = null; 
                    if (typeof r.default_stroke_width !== 'undefined') r.strokeWidthRatio = r.default_stroke_width;
                    if (typeof r.letter_spacing === 'undefined') r.letter_spacing = 0;
                    if (r.translation) {
                        r.translation = cleanTranslationText(r.translation);
                    }
                    // ã€è¿™æ˜¯æœ€å…³é”®çš„ä¸¤æ­¥ï¼Œé¡ºåºä¸èƒ½ä¹±ã€‘
                    // æ­¥éª¤ 1: å¿…é¡»å…ˆè¿˜åŸå°æ¡†åæ ‡ (å°† JSON é‡Œçš„â€œèººå¹³â€åæ ‡æŒ‰è§’åº¦ç«‹èµ·æ¥)
                    restoreLinesFromCenter(r); 
                    // æ­¥éª¤ 2: åŸºäºç«‹èµ·æ¥çš„åæ ‡ï¼Œé‡æ–°è®¡ç®—ç»¿è‰²å¤§æ¡† (Block)
                    initRegionBox(r); 
                });
                
                resizeCanvas();
                resetSidebar(); 
                updateBatchNavUI(); // ã€æ–°å¢ã€‘åŠ è½½å®Œé¡µé¢ååˆ·æ–°æŒ‰é’®çŠ¶æ€
                draw(); // æ‰§è¡Œé‡ç»˜
            };
            img.src = URL.createObjectURL(item.image);
        }

        // ç¿»é¡µå¯¼èˆª
        // --- [å…³é”®] ç¿»é¡µæ—¶ä¿å­˜æ•°æ® ---
        // --- [ä¼˜åŒ–] ç¿»é¡µæ—¶è‡ªåŠ¨ä¿å­˜å½“å‰é¡µä¿®æ”¹ ---
        // --- [åŠ å›ºç‰ˆ] ç¿»é¡µå¯¼èˆªï¼šå¢åŠ è¾¹ç•Œæ£€æŸ¥ä¸ UI åŒæ­¥ ---
        function navigateFiles(dir) {
            if (currentFileIndex === -1 || matchedFiles.length === 0) return;

            // 1. ä¿å­˜å½“å‰é¡µä¿®æ”¹
            if (matchedFiles[currentFileIndex]) {
                matchedFiles[currentFileIndex].regions = JSON.parse(JSON.stringify(regions));
            }

            // 2. è®¡ç®—æ–°ç´¢å¼•å¹¶æ£€æŸ¥ä¸Šä¸‹é™
            const newIdx = currentFileIndex + dir;
            
            if (newIdx >= 0 && newIdx < matchedFiles.length) {
                // åœ¨åˆæ³•èŒƒå›´å†…ï¼Œæ‰§è¡Œç¿»é¡µ
                currentFileIndex = newIdx;
                loadFile(currentFileIndex);
            } else {
                // è¶Šç•Œåé¦ˆï¼šæç¤ºå·²åˆ°å¤´
                const message = dir > 0 ? "å·²ç»æ˜¯æœ€åä¸€é¡µäº†" : "å·²ç»æ˜¯ç¬¬ä¸€é¡µäº†";
                console.warn(message);
                // å¼ºåˆ¶é‡ç½®è¾“å…¥æ¡†æ•°å­—ï¼Œé˜²æ­¢è¾“å…¥æ¡†æ•°å­—ä¸å®é™…é¡µç è„±é’©
                pageInput.value = currentFileIndex + 1;
            }
        }



        batchAutoFontSizeBtnRight.onclick = async () => {
            // 1. è‡ªåŠ¨åˆ¤æ–­æ¨¡å¼
            const isBatchMode = matchedFiles.length > 0;

            if (isBatchMode) {
                // --- æ‰¹é‡æ¨¡å¼é€»è¾‘ ---
                if (!confirm(`ç¡®å®šè¦ä¸ºæ‰€æœ‰é¡µé¢ï¼ˆå…± ${matchedFiles.length} é¡µï¼‰é‡æ–°è®¡ç®—å­—å·ä¸è¡Œè·å—ï¼Ÿ`)) return;

                if (matchedFiles[currentFileIndex]) {
                    matchedFiles[currentFileIndex].regions = JSON.parse(JSON.stringify(regions));
                }

                matchedFiles.forEach(fileItem => {
                    fileItem.regions.forEach(r => {
                        const autoSize = calculateAutoFontSizeForRegion(r);
                        r.font_size = autoSize;
                        r.line_spacing = calculateAutoLineSpacing(r, autoSize);
                    });
                });
                
                loadFile(currentFileIndex); // åˆ·æ–°æ˜¾ç¤º
            } else {
                // --- å• JSON æ¨¡å¼é€»è¾‘ ---
                if (regions.length === 0) {
                    alert("æœªæ£€æµ‹åˆ°æœ‰æ•ˆçš„åŒºåŸŸæ•°æ®ã€‚");
                    return;
                }
                
                // ä¸ºå½“å‰é¡µæ‰€æœ‰æ¡†æ‰§è¡Œä¼˜åŒ–
                regions.forEach(r => {
                    const autoSize = calculateAutoFontSizeForRegion(r);
                    r.font_size = autoSize;
                    r.line_spacing = calculateAutoLineSpacing(r, autoSize);
                });
                
                draw(); // ç«‹å³é‡ç»˜ç”»å¸ƒ
            }

            // è§†è§‰åé¦ˆ
            const originalText = batchAutoFontSizeBtnRight.innerText;
            batchAutoFontSizeBtnRight.innerText = "OK!";
            batchAutoFontSizeBtnRight.classList.add('text-green-400');
            setTimeout(() => {
                batchAutoFontSizeBtnRight.innerText = originalText;
                batchAutoFontSizeBtnRight.classList.remove('text-green-400');
            }, 1000);
        };


        // --- å½»åº•ä¿®å¤ï¼šå…¨é‡å›¾ç‰‡å¯¼å‡ºé€»è¾‘ ---
        async function handleExport() {
            if (matchedFiles.length === 0) {
                exportImage();
                return;
            }

            const btn = document.getElementById('btnExport');
            const originalText = btn.innerText;
            
            try {
                btn.innerText = "æ­£åœ¨æ¸²æŸ“...";
                btn.disabled = true;

                if (matchedFiles[currentFileIndex]) {
                    matchedFiles[currentFileIndex].regions = JSON.parse(JSON.stringify(regions));
                }

                const zip = new JSZip();
                const offCanvas = document.createElement('canvas');
                const offCtx = offCanvas.getContext('2d');

                for (let i = 0; i < matchedFiles.length; i++) {
                    const item = matchedFiles[i];
                    btn.innerText = `å¤„ç†ä¸­ (${i + 1}/${matchedFiles.length})`;

                    // ã€æ ¸å¿ƒä¿®å¤ã€‘ï¼šåˆ¤æ–­å¦‚æœæœ‰ä¿®å¤å›¾ï¼Œåˆ™åŠ è½½ä¿®å¤å›¾ï¼Œå¦åˆ™åŠ è½½åŸå›¾
                    const imageToLoad = item.repairImage ? item.repairImage : item.image;

                    const img = await new Promise((resolve, reject) => {
                        const tempImg = new Image();
                        tempImg.onload = () => resolve(tempImg);
                        tempImg.onerror = reject;
                        tempImg.src = URL.createObjectURL(imageToLoad);
                    });

                    offCanvas.width = img.width;
                    offCanvas.height = img.height;
                    offCtx.drawImage(img, 0, 0);

                    const realCtx = window.ctx; 
                    window.ctx = offCtx; 
                    ctx = offCtx; 

                    const savedMode = displayMode;
                    displayMode = 'translation'; 

                    item.regions.forEach(r => {
                        drawSmartTranslation(r); 
                    });

                    displayMode = savedMode;
                    window.ctx = realCtx;
                    ctx = realCtx;

                    const imgBlob = await new Promise(resolve => offCanvas.toBlob(resolve, 'image/png'));
                    const pureName = item.image.name.substring(0, item.image.name.lastIndexOf('.'));
                    zip.file(`${pureName}_translated.png`, imgBlob);
                    
                    URL.revokeObjectURL(img.src); 
                }

                btn.innerText = "æ­£åœ¨æ‰“åŒ…...";
                const content = await zip.generateAsync({ type: "blob" });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = `MTU_Images_${new Date().getTime()}.zip`;
                link.click();

            } catch (err) {
                console.error("å¯¼å‡ºå¤±è´¥:", err);
                alert("å¯¼å‡ºå¤±è´¥: " + err.message);
            } finally {
                btn.innerText = originalText;
                btn.disabled = false;
            }
        }

        // é‡æ–°ç»‘å®šå”¯ä¸€æŒ‰é’®äº‹ä»¶
        btnExport.onclick = handleExport;

        // ç»‘å®šåˆ°æŒ‰é’®
        btnExport.onclick = handleExport;

        function disableControls() {
            fontSizeInput.disabled = true; fontSizeInput.value = '';
            lineSpacingInput.disabled = true; lineSpacingInput.value = '';
            letterSpacingInput.disabled = true; letterSpacingInput.value = '';
        }
        function scrollToSidebar(i) { const item = document.getElementById(`sb-${i}`); if(item) item.scrollIntoView({behavior:'smooth', block:'center'}); }
        function getMousePos(e) { 
            const rect = document.getElementById('canvasContainer').getBoundingClientRect();
            // é¼ æ ‡åœ¨å®¹å™¨å†…çš„åæ ‡
            const clientX = e.clientX - rect.left;
            const clientY = e.clientY - rect.top;

            // åæ¨å›ç”»å¸ƒåæ ‡ï¼š (å®¹å™¨åæ ‡ - åç§»é‡) / ç¼©æ”¾æ¯”ä¾‹
            return { 
                x: (clientX - viewState.x) / viewState.scale, 
                y: (clientY - viewState.y) / viewState.scale 
            }; 
        }
        // ä¿®æ”¹ MTU ä¸­çš„ findRegionAt å‡½æ•°
        function findRegionAt(pos) {
            // é€†åºéå†åŒºåŸŸï¼Œç¡®ä¿é€‰ä¸­æœ€ä¸Šå±‚çš„å…ƒç´ 
            for (let i = regions.length - 1; i >= 0; i--) {
                const r = regions[i];
                
                if (r.lines) {
                    // æ·±å…¥éå†åŒºåŸŸå†…çš„æ¯ä¸€ä¸ªå°æ¡†ï¼ˆè¡Œï¼‰
                    for (let j = 0; j < r.lines.length; j++) {
                        // ä½¿ç”¨å°„çº¿æ³•åˆ¤æ–­ç‚¹å‡»ä½ç½®æ˜¯å¦åœ¨å½“å‰è¡Œçš„å°æ¡†å†…
                        if (isPointInPolygon(pos, r.lines[j])) {
                            return { regionIdx: i, lineIdx: j }; // è¿”å›åŒé‡ç´¢å¼•
                        }
                    }
                }

                // å¤‡é€‰æ–¹æ¡ˆï¼šå¦‚æœæ²¡ç‚¹ä¸­å°æ¡†ï¼Œæ£€æŸ¥æ˜¯å¦ç‚¹ä¸­äº†å¤§æ¡†èŒƒå›´
                if (r.box) {
                    const [x1, y1, x2, y2] = r.box;
                    if (pos.x >= x1 && pos.x <= x2 && pos.y >= y1 && pos.y <= y2) {
                        return { regionIdx: i, lineIdx: -1 }; 
                    }
                }
            }
            return null;
        }
        function isPointInPolygon(p, vs) {
            let inside = false;
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                if (((vs[i][1] > p.y) != (vs[j][1] > p.y)) && (p.x < (vs[j][0] - vs[i][0]) * (p.y - vs[i][1]) / (vs[j][1] - vs[i][1]) + vs[i][0])) inside = !inside;
            }
            return inside;
        }
        function getPolygonCenter(p) { let x=0,y=0; p.forEach(pt=>{x+=pt[0];y+=pt[1]}); return {x:x/p.length, y:y/p.length}; }
        function parseColor(color) {
            if (!color) return null;
            if (Array.isArray(color) && color.length === 3) return `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            return typeof color === 'string' ? color : null;
        }
        function colorToHex(c) {
            if(!c) return "#000000"; // é»‘è‰²
            if(c.startsWith('#')) return c;
            const rgb = c.match(/\d+/g);
            if(rgb) return "#" + ((1<<24)+(+rgb[0]<<16)+(+rgb[1]<<8)+(+rgb[2])).toString(16).slice(1);
            return '#000000'; // é»‘è‰²
        }

        /**
        * æ ¹æ®æ—‹è½¬è§’åº¦åŠ¨æ€è·å–å…‰æ ‡æ–¹å‘
        * @param {number} boxAngle - å¤§æ¡†å½“å‰è§’åº¦
        * @param {number} handleIndex - æ‰‹æŸ„ç´¢å¼• (0-7)
        */
        /**
        * ä¿®æ­£ç‰ˆï¼šæ ¹æ®æ—‹è½¬è§’åº¦åŠ¨æ€è·å–æœ€æ¥è¿‘æ³•çº¿çš„å…‰æ ‡
        */
        function getTiltedCursor(boxAngle, handleIndex) {
            // 1. å®šä¹‰æ¯ä¸ªæ‰‹æŸ„åœ¨ 0 åº¦æ—¶çš„ç»å¯¹ç‰©ç†è§’åº¦ (æ•°å­¦æåæ ‡ç³»)
            // 0:å·¦ä¸Š(-135Â°), 1:å³ä¸Š(-45Â°), 2:å³ä¸‹(45Â°), 3:å·¦ä¸‹(135Â°)
            // 4:é¡¶ä¸­(-90Â°), 5:å³ä¸­(0Â°), 6:åº•ä¸­(90Â°), 7:å·¦ä¸­(180Â°)
            const handleAngles = [315, 45, 135, 225, 270, 0, 90, 180];
            
            // 2. è®¡ç®—å½“å‰æ‰‹æŸ„åœ¨å…¨å±€ç©ºé—´çš„æ€»è§’åº¦
            let totalAngle = (boxAngle + handleAngles[handleIndex]) % 360;
            if (totalAngle < 0) totalAngle += 360;
            
            // 3. å°† 360 åº¦åˆ’åˆ†ä¸º 8 ä¸ªæ ¸å¿ƒæ‰‡åŒº (æ¯ 45 åº¦ä¸€ä¸ªå›¾æ ‡)
            // ä¿®æ­£äº†åŒºé—´åˆ¤æ–­ï¼Œä½¿å…¶æ›´åŠ å¹³æ»‘
            if ((totalAngle >= 337.5 || totalAngle < 22.5) || (totalAngle >= 157.5 && totalAngle < 202.5)) 
                return 'ew-resize';   // æ°´å¹³å‘
            if ((totalAngle >= 22.5 && totalAngle < 67.5) || (totalAngle >= 202.5 && totalAngle < 247.5)) 
                return 'nwse-resize'; // å·¦ä¸Š-å³ä¸‹å‘
            if ((totalAngle >= 67.5 && totalAngle < 112.5) || (totalAngle >= 247.5 && totalAngle < 292.5)) 
                return 'ns-resize';   // å‚ç›´å‘
            if ((totalAngle >= 112.5 && totalAngle < 157.5) || (totalAngle >= 292.5 && totalAngle < 337.5)) 
                return 'nesw-resize'; // å³ä¸Š-å·¦ä¸‹å‘
                
            return 'default';
        }
        function isHalfWidth(char) { const code = char.charCodeAt(0); return (code >= 0x0020 && code <= 0x007E) || (code >= 0xFF61 && code <= 0xFF9F); }
        function getCharVerticalHeight(char, fontSize) {
            if (ROTATED_LETTERS_NUMBERS.includes(char)) return fontSize;
            if (CHARS_TO_ROTATE.includes(char) || CHARS_VERTICAL_COMPRESSION.includes(char) || isHalfWidth(char)) return fontSize * 0.5;
            return fontSize;
        }
        // [æ–°å¢] å°† JSON ä¸­â€œæ‰¶æ­£â€çš„ lines ç»“åˆ angle è¿˜åŸå›åŸå›¾ä¸Šçš„æ—‹è½¬åæ ‡
        function restoreLinesFromCenter(region) {
            // å¦‚æœæ²¡æœ‰ angle æˆ–è€… angle ä¸º 0ï¼Œå°±ä¸éœ€è¦è¿˜åŸ
            if (!region.lines || region.lines.length === 0 || typeof region.angle !== 'number' || region.angle === 0) {
                return;
            }

            // 1. è®¡ç®—æ‰€æœ‰ç‚¹çš„å‡ ä½•ä¸­å¿ƒ (Center)
            let totalX = 0, totalY = 0, count = 0;
            region.lines.forEach(line => {
                line.forEach(pt => {
                    totalX += pt[0];
                    totalY += pt[1];
                    count++;
                });
            });
            if (count === 0) return;
            const cx = totalX / count;
            const cy = totalY / count;

            // 2. å‡†å¤‡æ—‹è½¬å‚æ•° (æ­£å‘æ—‹è½¬)
            // å¯¹åº” Python: math.radians(angle)
            const rad = region.angle * Math.PI / 180;
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);

            // 3. å¯¹æ¯ä¸ªç‚¹æ‰§è¡Œæ—‹è½¬å…¬å¼
            // å¯¹åº” Python: 
            // new_x = dx * cos - dy * sin
            // new_y = dx * sin + dy * cos
            const newLines = region.lines.map(line => {
                return line.map(pt => {
                    const dx = pt[0] - cx;
                    const dy = pt[1] - cy;
                    return [
                        dx * cos - dy * sin + cx,
                        dx * sin + dy * cos + cy
                    ];
                });
            });

            // 4. æ›´æ–° lines
            region.lines = newLines;
        }
        /**
         * æ ¸å¿ƒç®—æ³•ï¼šåŸºäºåŸæ–‡è®¡ç®—è‡ªåŠ¨å­—å·
         */
        function calculateAutoFontSizeForRegion(region) {
            // å…¼å®¹é€»è¾‘ï¼šä¼˜å…ˆå– texts æ•°ç»„ï¼ˆåŸæ–‡ï¼‰ï¼Œæ²¡æœ‰åˆ™å– translation
            const textSource = region.texts || (region.translation ? region.translation.split('ã€BRã€‘') : []);
            if (textSource.length === 0 || !region.lines) return 20;

            let minFontSize = Infinity;
            const isVertical = region.direction === 'v';
            // ã€æ–°å¢ï¼šå®šä¹‰æ‰€éœ€å˜é‡ã€‘
            // è¿™é‡Œçš„é€»è¾‘ä¸ drawSmartTranslation ä¿æŒä¸€è‡´ï¼šä¼˜å…ˆå–åŒºåŸŸè‡ªå®šä¹‰å­—ä½“ï¼Œå¦åˆ™å–å…¨å±€é»˜è®¤å­—ä½“
            const effectiveFont = region.fontFamily || activeFontFamily;
            
            region.lines.forEach((polygon, lineIndex) => {
                const text = textSource[lineIndex] || "";
                if (!text) return;

                const p0 = polygon[0], p1 = polygon[1], p2 = polygon[2], p3 = polygon[3];
                // è®¡ç®—æ¡†çš„å¹³å‡å®½å’Œé«˜
                const avgWidth = (Math.hypot(p1[0] - p0[0], p1[1] - p0[1]) + Math.hypot(p2[0] - p3[0], p2[1] - p3[1])) / 2;
                const avgHeight = (Math.hypot(p3[0] - p0[0], p3[1] - p0[1]) + Math.hypot(p2[0] - p1[0], p2[1] - p1[1])) / 2;

                let totalUnits = 0;
                let suggestedSize = 0;

                if (isVertical) {
                    // --- ç«–æ’é€»è¾‘ ---
                    // å¤„ç† TCYï¼ˆæ¨ªæ’æ•°å­—ï¼‰ï¼Œå°†å…¶è§†ä¸º 1 ä¸ªå•ä½é«˜åº¦ 
                    const tcyProcessedText = text.replace(/([\d\uFF10-\uFF19]{2,4})/g, "T");
                    for (const char of tcyProcessedText) {
                        if (char === 'T') {
                            totalUnits += 1.0;
                        } else if (isHalfWidth(char) || CHARS_VERTICAL_COMPRESSION.includes(char) || CHARS_SYMMETRIC_HALF.includes(char)) {
                            totalUnits += 0.5; // å‹ç¼©æ ‡ç‚¹æˆ–åŠè§’è®¡ 0.5
                        } else {
                            totalUnits += 1.0; // æ™®é€šå…¨è§’è®¡ 1.0
                        }
                    }
                    suggestedSize = totalUnits > 0 ? (avgHeight / totalUnits) : avgHeight;
                // --- æ›¿æ¢åŸæœ¬çš„ else { for (const char of text) { ... } } éƒ¨åˆ† ---
                }else {
                    // æ¨ªæ’åƒç´ æ„ŸçŸ¥ç®—æ³•
                    let totalPixelWidthAt100px = 0;
                    const testFS = 100; // ä½¿ç”¨ 100px ä½œä¸ºæµ‹é‡åŸºå‡†
                    ctx.font = `${testFS}px ${effectiveFont}`; // ç¡®ä¿ä½¿ç”¨å½“å‰è®¾ç½®çš„å­—ä½“

                    for (const char of text) {
                        let charW;
                        // è¿™é‡Œçš„åˆ¤å®šé€»è¾‘å¿…é¡»å’Œ drawSmartTranslation é‡Œçš„æ¸²æŸ“é€»è¾‘å®Œå…¨ä¸€è‡´
                        if (CHARS_SYMMETRIC_HALF.includes(char) || CHARS_PUNCT.includes(char)) {
                            charW = testFS * 0.5; // æ¨¡æ‹Ÿæ¸²æŸ“æ—¶çš„å¼ºåˆ¶åŠå®½
                        } else if (isHalfWidth(char)) {
                            charW = ctx.measureText(char).width; 
                        } else {
                            charW = testFS; // æ ‡å‡†å…¨è§’
                        }
                        
                        // ã€å…³é”®ä¿®å¤ã€‘ï¼šæŠŠå­—é—´è·ä¹Ÿç®—è¿›å» (è½¬ä¸º 100px ä¸‹çš„å¯¹åº”æ¯”ä¾‹)
                        // å‡è®¾ region.letter_spacing æ˜¯å€ç‡ (å¦‚ 0.1 è¡¨ç¤º 10% å­—å·)
                        const spacing = testFS * (region.letter_spacing || 0);
                        totalPixelWidthAt100px += charW + spacing;
                    }

                    // æ ¹æ®æµ‹é‡å‡ºçš„ 100px æ€»å®½ï¼Œåæ¨æœ€é€‚åˆå®¹å™¨å®½åº¦çš„å­—å·
                    suggestedSize = totalPixelWidthAt100px > 0 ? (testFS * (avgWidth / totalPixelWidthAt100px)) : avgWidth;
                }

                // æ›´æ–°å…¨å±€æœ€å°å­—å·
                if (suggestedSize < minFontSize) {
                    minFontSize = suggestedSize;
                }
            });

            // é™åˆ¶å­—å·èŒƒå›´ï¼Œé˜²æ­¢å‡ºç°æç«¯æ•°å€¼
            const result = minFontSize === Infinity ? 20 : minFontSize;
            return parseFloat(Math.max(5, Math.min(result, 200)).toFixed(2));
        }

        // è®¡ç®—å•è¡Œæ–‡å­—çš„å»ºè®®å­—å·ï¼ˆå¤åˆ»è‡ª Angle é€»è¾‘ï¼‰
        function getSingleLineAutoFontSize(text, polygon, isVertical) {
            if (!text || text.length === 0) return 20;
            
            // è®¡ç®—æ¡†çš„å¹³å‡å®½/é«˜
            const p0 = polygon[0], p1 = polygon[1], p2 = polygon[2], p3 = polygon[3];
            const avgW = (Math.hypot(p1[0]-p0[0], p1[1]-p0[1]) + Math.hypot(p2[0]-p3[0], p2[1]-p3[1])) / 2;
            const avgH = (Math.hypot(p3[0]-p0[0], p3[1]-p0[1]) + Math.hypot(p2[0]-p1[0], p2[1]-p1[1])) / 2;

            if (isVertical) {
                // ç«–æ’é€»è¾‘ï¼šé«˜åº¦ / å­—ç¬¦å•ä½
                let units = 0;
                const tcyText = text.replace(/([\d\uFF10-\uFF19]{2,4})/g, "T");
                for (const char of tcyText) {
                    units += (char === 'T' || !isHalfWidth(char)) ? 1.0 : 0.5;
                }
                return units > 0 ? (avgH / units) : avgH;
            } else {
                // æ¨ªæ’é€»è¾‘ï¼šå®½åº¦ / æµ‹é‡é•¿åº¦
                const tempFS = 100;
                ctx.font = `${tempFS}px "Noto Sans JP", sans-serif`;
                const mWidth = ctx.measureText(text).width;
                return mWidth > 0 ? (tempFS * (avgW / mWidth)) : avgH;
            }
        }
        function calculateAutoLineSpacing(region, fontSize) {
            if (!region.lines || region.lines.length < 2 || !fontSize) return 1.2;
            const n = region.lines.length;
            const isVertical = region.direction === 'v';
            const angle = region.angle || 0;

            // --- ä½¿ç”¨ä½ æœ€ç†Ÿæ‚‰çš„ä»¥å‰çš„ä¸­å¿ƒç®—æ³• ---
            const getCenter = (poly) => {
                let cx = 0, cy = 0;
                poly.forEach(p => { cx += p[0]; cy += p[1]; });
                return { x: cx / 4, y: cy / 4 };
            };

            const c1 = getCenter(region.lines[0]);
            const cn = getCenter(region.lines[n - 1]);
            const dx = cn.x - c1.x;
            const dy = cn.y - c1.y;

            let totalDist = 0;

            // --- é€»è¾‘æ•´åˆï¼š0åº¦æ—¶ç­‰åŒäºåŸç‰ˆï¼Œæœ‰è§’åº¦æ—¶è‡ªåŠ¨æŠ•å½± ---
            const rad = angle * Math.PI / 180;
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);

            if (isVertical) {
                // æ—‹è½¬åæ ‡ç³»ä¸‹çš„æ°´å¹³ä½ç§»ï¼šdx' = dx*cos + dy*sin
                totalDist = Math.abs(dx * cos + dy * sin);
            } else {
                // æ—‹è½¬åæ ‡ç³»ä¸‹çš„å‚ç›´ä½ç§»ï¼šdy' = -dx*sin + dy*cos
                totalDist = Math.abs(-dx * sin + dy * cos);
            }

            const avgDist = totalDist / (n - 1);
            const spacingMult = avgDist / fontSize;
            return Math.min(Math.max(parseFloat(spacingMult.toFixed(2)), 0.5), 3.0);
        }

        // è‡ªåŠ¨åº”ç”¨æŒ‰é’®
        // 1. ä»…è‡ªåŠ¨å­—å·æŒ‰é’®çš„é€»è¾‘
        function applyAutoFontSize() {
            if (activeRegionIndex === -1) {
                if(!confirm("ç¡®å®šè¦ä¸ºé¡µé¢ä¸Šæ‰€æœ‰åŒºåŸŸé‡æ–°è®¡ç®—å­—å·å—ï¼Ÿ")) return;
                regions.forEach(r => { r.font_size = calculateAutoFontSizeForRegion(r); });
            } else {
                const r = regions[activeRegionIndex];
                r.font_size = calculateAutoFontSizeForRegion(r);
                document.getElementById('fontSizeInput').value = r.font_size.toFixed(1);
            }
            draw();
        };

        // 2. ä»…è‡ªåŠ¨è¡Œè·æŒ‰é’®çš„é€»è¾‘
        function applyAutoLineSpacing() {
            if (activeRegionIndex === -1) {
                if(!confirm("ç¡®å®šè¦ä¸ºæ‰€æœ‰åŒºåŸŸè‡ªåŠ¨è®¡ç®—è¡Œè·å—ï¼Ÿ")) return;
                regions.forEach(r => {
                    const fs = r.font_size || calculateAutoFontSizeForRegion(r);
                    r.line_spacing = calculateAutoLineSpacing(r, fs);
                });
            } else {
                const r = regions[activeRegionIndex];
                // å¦‚æœå½“å‰æ²¡è®¾å­—å·ï¼Œå…ˆä¸´æ—¶ç®—ä¸€ä¸ªä½œä¸ºåŸºå‡†
                const fs = r.font_size || calculateAutoFontSizeForRegion(r);
                r.line_spacing = calculateAutoLineSpacing(r, fs);
                document.getElementById('lineSpacingInput').value = r.line_spacing.toFixed(2);
            }
            draw();
        };

        /**
        * å½’ä½åŠŸèƒ½ï¼šå®ç°â€œæ–œâ€ï¼ˆæ™ºèƒ½æ¢æµ‹ï¼‰ä¸â€œç›´â€ï¼ˆå¼ºåˆ¶è½¬æ­£ï¼‰
        * @param {string} mode - 'slanted' (æ™ºèƒ½è§’åº¦) æˆ– 'straight' (å¼ºåˆ¶ 0 åº¦)
        */
        function recalibrateMode(mode) {
            if (activeRegionIndex === -1 || !regions[activeRegionIndex]) return;
            const r = regions[activeRegionIndex];

            if (mode === 'slanted') {
                // --- â€œæ–œâ€ï¼šé‡æ–°è®¡ç®—æœ€å¥‘åˆçš„å€¾æ–œè§’åº¦ ---
                // 1. å°†è§’åº¦è®¾ä¸º nullï¼Œè§¦å‘ initRegionBox å†…éƒ¨çš„è§’åº¦åˆ¤å®šé€»è¾‘
                r.angle = null; 
                initRegionBox(r); // initRegionBox ä¼šæ ¹æ® lines å‘é‡é‡æ–°æ¨ç®— angle å¹¶é‡æ–°è®¡ç®— box
            } else {
                // --- â€œç›´â€ï¼šå¼ºåˆ¶è½¬æ­£ä¸º 0 åº¦ ---
                // 1. å°†è§’åº¦å¼ºåˆ¶è®¾ä¸º 0
                r.angle = 0; 
                // 2. åœ¨ 0 åº¦å§¿æ€ä¸‹é‡æ–°è®¡ç®—åŒ…å›´ç›’
                calculateBoxFromLines(r); 
            }

            // è§†è§‰åé¦ˆï¼šæŒ‰é’®æˆåŠŸæç¤º
            const btn = event.currentTarget;
            const originalText = btn.innerText;
            btn.innerText = "OK";
            setTimeout(() => { btn.innerText = originalText; }, 600);

            draw();
        }
        function deleteActiveLine() {
            if (activeRegionIndex === -1 || activeLineIndex === -1) return;
            
            const r = regions[activeRegionIndex];
            // 1. åˆ é™¤è¯¥è¡Œçš„åæ ‡å’Œå¯¹åº”çš„æ–‡æœ¬
            r.lines.splice(activeLineIndex, 1);
            if (r.texts) r.texts.splice(activeLineIndex, 1);
            
            // 2. å¦‚æœè¡Œè¢«åˆ å…‰äº†ï¼Œåˆ é™¤æ•´ä¸ªåŒºåŸŸ
            if (r.lines.length === 0) {
                regions.splice(activeRegionIndex, 1);
                resetSidebar();
            } else {
                // 3. æ¨¡ä»¿ Angleï¼šåˆ é™¤è¡Œåé‡æ–°è®¡ç®—å¤§æ¡†
                initRegionBox(r);
                activeLineIndex = -1; // é‡ç½®é€‰ä¸­è¡Œ
                setActiveRegion(activeRegionIndex); // åˆ·æ–°ä¾§è¾¹æ å†…å®¹
            }
            draw();
        }

        /**
        * åˆ¤æ–­é¢œè‰²æ˜¯å¦æ¥è¿‘ç™½è‰² (å¸¦å®¹å·®)
        * @param {string} hex - 16è¿›åˆ¶é¢œè‰²å€¼ (å¦‚ #ffffff)
        * @param {number} threshold - å®¹å·®é˜ˆå€¼ (0-255)ï¼Œè¶Šé«˜è¶Šæ¥è¿‘çº¯ç™½ï¼Œå»ºè®® 220
        */
        function isNearWhite(hex, threshold = 220) {
            if (!hex || !hex.startsWith('#')) return false;
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            // å¦‚æœçº¢ç»¿è“ä¸‰ä¸ªåˆ†é‡éƒ½é«˜äºé˜ˆå€¼ï¼Œåˆ™è®¤ä¸ºæ˜¯ç™½è‰²ç³»
            return r > threshold && g > threshold && b > threshold;
        }

        // --- æ–°å¢å˜é‡ ---
        const editorContainer = document.getElementById('editorContainer');
        const emptyState = document.getElementById('emptyState');

        

        // --- é”®ç›˜å¿«æ·é”® (ä¸Šä¸€æ¡/ä¸‹ä¸€æ¡/ä¿å­˜) ---
        // --- [ä¿®æ­£ç‰ˆ] å…¨å±€å¿«æ·é”®ï¼šå¯¹é½æ—¥æ¼«é€»è¾‘ ---
        // --- å…¨å±€å¿«æ·é”®ï¼šæ—¥æ¼«æ¨¡å¼ç¿»é¡µä¸å­—å·è°ƒèŠ‚ ---
        window.addEventListener('keydown', (e) => {
            // ä¿æŠ¤é€»è¾‘ï¼šå¦‚æœæ­£åœ¨æ‰“å­—ï¼Œä¸è§¦å‘ç¿»é¡µ
            const isEditing = document.activeElement === transEditArea || 
                            document.activeElement === origEditArea ||
                            document.activeElement === pageInput;
            if (isEditing && e.key !== 'Enter') return; 

            // æ—¥æ¼«é€»è¾‘ï¼šå·¦é”®ä¸‹ä¸€é¡µï¼Œå³é”®ä¸Šä¸€é¡µ
            if (e.key === 'ArrowLeft') { e.preventDefault(); navigateFiles(1); }
            if (e.key === 'ArrowRight') { e.preventDefault(); navigateFiles(-1); }

            // å­—å·è°ƒèŠ‚ (æ­¥è¿› 0.5)
            if (activeRegionIndex !== -1 && regions[activeRegionIndex]) {
                const r = regions[activeRegionIndex];
                if (e.key === '[') {
                    r.font_size = Math.max(1, (parseFloat(r.font_size) || 20) - 0.5);
                    fontSizeInput.value = r.font_size.toFixed(1);
                    draw();
                }
                if (e.key === ']') {
                    r.font_size = (parseFloat(r.font_size) || 20) + 0.5;
                    fontSizeInput.value = r.font_size.toFixed(1);
                    draw();
                }
            }
            if (e.key === 'Delete') {
                // åªæœ‰åœ¨æ²¡åœ¨æ–‡æœ¬æ¡†æ‰“å­—æ—¶æ‰è§¦å‘
                if (document.activeElement !== transEditArea && document.activeElement !== origEditArea) {
                    deleteActiveLine();
                }
            }
        });


        drawModeBtnRight.onclick = () => {
            isDrawingMode = !isDrawingMode;
            const btn = document.getElementById('drawModeBtnRight');
            const container = document.getElementById('canvasContainer');
            
            btn.classList.toggle('bg-yellow-600', isDrawingMode);
            btn.classList.toggle('text-white', isDrawingMode);
            
            // å¦‚æœè¿›å…¥æ¨¡å¼ï¼Œåˆ‡æ¢ä¸ºåå­—å…‰æ ‡ï¼›é€€å‡ºåˆ™æ¢å›æŠ“æ‰‹
            container.style.cursor = isDrawingMode ? 'crosshair' : 'grab';

            if (isDrawingMode) {
                activeRegionIndex = -1;
                activeLineIndex = -1;
                resetSidebar();
            }
            draw();
        };

        

        // --- æ ¸å¿ƒé€»è¾‘æ›´æ–° ---

        // 1. ä¿å­˜å½“å‰ç¼–è¾‘å†…å®¹
        function saveSidebarContent() {
            if (activeRegionIndex !== -1 && regions[activeRegionIndex]) {
                const r = regions[activeRegionIndex];

                // --- 1. æäº¤è¯‘æ–‡ä¿®æ”¹ ---
                r.translation = document.getElementById('transEditArea').value.replace(/\n/g, 'ã€BRã€‘');
                
                // --- 2. æäº¤åŸæ–‡ä¿®æ”¹ ---
                r.texts = document.getElementById('origEditArea').value.split('\n');

                // æ›´æ–°å¿«ç…§ï¼Œä½¿å½“å‰çŠ¶æ€æˆä¸ºæ–°çš„â€œåŸå§‹çŠ¶æ€â€
                r.transSnapshot = r.translation;
                r.origSnapshot = [...r.texts];

                // è§†è§‰åé¦ˆ
                const btn = document.getElementById('btnSaveSidebar');
                const oldText = btn.innerText;
                btn.innerText = "æç¤ºï¼šshift+å·¦é”®å•å‡» å¯å¤šé€‰å¤šä¸ªè¡Œæ¡†";
                btn.classList.add('bg-green-600');
                setTimeout(() => {
                    btn.innerText = oldText;
                    btn.classList.remove('bg-green-600');
                }, 800);

                draw();
            }
        }

        // 2. åˆ‡æ¢ä¸Šä¸€æ¡/ä¸‹ä¸€æ¡
        function navigateRegion(dir) {
            if (regions.length === 0) return;
            let newIndex = activeRegionIndex + dir;
            if (newIndex < 0) newIndex = regions.length - 1;
            if (newIndex >= regions.length) newIndex = 0;
            setActiveRegion(newIndex);
        }

        // 3. æ›´æ–° setActiveRegion (å…³é”®ï¼šå¡«å……ä¾§è¾¹æ )
        // è¦†ç›–åŸæœ¬çš„ setActiveRegion å‡½æ•°
        /**
        * æ ¸å¿ƒé€‰ä¸­é€»è¾‘ï¼šåŒæ­¥æ‰€æœ‰ UI æ§ä»¶çŠ¶æ€åˆ°ä¾§è¾¹æ 
        * @param {number} i - é€‰ä¸­çš„åŒºåŸŸç´¢å¼•
        */
        function setActiveRegion(i) {
            activeRegionIndex = i;
            const r = regions[i];
            if (!r) return;

            // --- A. å»ºç«‹é‡ç½®å¿«ç…§ (åŒæ¡†åˆ†å¼€å­˜å‚¨) ---
            r.transSnapshot = r.translation || "";      // å­˜å‚¨è¯‘æ–‡å¿«ç…§
            r.origSnapshot = [...(r.texts || [])];     // å­˜å‚¨åŸæ–‡å¿«ç…§ (æ·±æ‹·è´æ•°ç»„)

            // --- B. UI çŠ¶æ€åˆ‡æ¢ ---
            const container = document.getElementById('editorContainer');
            container.style.opacity = '1';
            container.style.pointerEvents = 'auto';
            sidebarStatus.innerHTML = `<span class="text-yellow-500">#${i + 1}</span> / ${regions.length}`;

            // --- C. å¡«å……å†…å®¹ ---
            // è¯‘æ–‡æ¡†ï¼šå¤„ç†æ¢è¡Œç¬¦
            document.getElementById('transEditArea').value = (r.translation || "").replace(/ã€BRã€‘/g, '\n');
            // åŸæ–‡æ¡†ï¼šæ•°ç»„è½¬å¤šè¡Œ
            document.getElementById('origEditArea').value = (r.texts || []).join('\n');



            // --- D. åŒæ­¥å…¶ä»–å±æ€§ (å­—å·ã€å­—ä½“ç­‰) ---
            fontSizeInput.disabled = false;
            fontSizeInput.value = (r.font_size || 20).toFixed(1);
            lineSpacingInput.disabled = false;
            lineSpacingInput.value = (r.line_spacing || 1.2).toFixed(2);
            letterSpacingInput.disabled = false;
            letterSpacingInput.value = (r.letter_spacing || 0).toFixed(2);
            textAlignSelect.value = r.textAlign || activeTextAlign;
            fontWeightSelect.value = r.fontWeight || activeFontWeight;

            // åœ¨ setActiveRegion(i) å‡½æ•°æœ«å°¾æ·»åŠ ï¼š
            document.getElementById('blurEnable').checked = !!r.blurEnable;
            // å°†åŸæ¥çš„æ•°å€¼ä½œä¸ºå€ç‡æ˜¾ç¤ºï¼Œæ¯”å¦‚ 0.1 è¡¨ç¤º 10% çš„å­—å·
            document.getElementById('blurSizeInput').value = r.blurSizeRatio || 0.1;
            document.getElementById('btnBlurColor').style.backgroundColor = r.blurColor || "#000000";

            updateColorSwatches();
            draw();
        }

        // 4. é‡ç½®ä¾§è¾¹æ  (ç‚¹å‡»ç©ºç™½å¤„æ—¶)
        // ä¿®æ”¹åŸæœ¬çš„ onMouseDown é‡Œçš„ else åˆ†æ”¯
        function resetSidebar() {
            activeRegionIndex = -1;
            
            // 1. ä¸å†éšè— editorContainerï¼Œè€Œæ˜¯è®©å®ƒå˜æ·¡ã€ç¦ç”¨
            const container = document.getElementById('editorContainer');
            container.style.opacity = '0.3';          // å˜åŠé€æ˜
            container.style.pointerEvents = 'none';   // ç¦æ­¢ç‚¹å‡»
            
            // 2. æ›´æ–°é¡¶éƒ¨çŠ¶æ€æ–‡å­—
            sidebarStatus.innerText = "æœªé€‰æ‹©åŒºåŸŸ";
            
            // 3. æ¸…ç©ºæ–‡æœ¬æ¡†å’Œè¾“å…¥æ¡†ï¼Œé¿å…è¯¯è§£
            transEditArea.value = '';
            // å¦‚æœå¸Œæœ›ä¿ç•™ä¸Šä¸€æ¬¡çš„å­—ä½“è®¾ç½®ä»¥ä¾¿æŸ¥çœ‹ï¼Œå¯ä»¥ä¸é‡ç½®ä¸‹é¢è¿™äº›ï¼Œ
            // ä½†ä¸ºäº†è¡¨ç¤ºâ€œæ— é€‰ä¸­â€ï¼Œé€šå¸¸å»ºè®®ç¦ç”¨ï¼š
            disableControls(); 
            
            updateColorSwatches();
            
            // æ¢å¤å…¨å±€å¯¹é½è®¾ç½®æ˜¾ç¤ºï¼ˆå¯é€‰ï¼‰
            textAlignSelect.value = activeTextAlign;
        }

        // ä¿®æ”¹ onMouseDown çš„è¿™éƒ¨åˆ†é€»è¾‘
        /* åœ¨åŸ onMouseDown å‡½æ•°ä¸­ï¼š
           if (idx !== -1) setActiveRegion(idx);
           else { 
               // æ›¿æ¢åŸæ¥çš„ disableControls(); renderSidebar(); ç­‰ä»£ç 
               resetSidebar();
               draw(); 
           }
        */

        // 5. åˆ«å¿˜äº†æŠŠä¹‹å‰çš„è¿˜åŸå‡½æ•°åŠ ä¸Š
        function restoreLinesFromCenter(region) {
            if (!region.lines || region.lines.length === 0 || typeof region.angle !== 'number' || region.angle === 0) return;
            let totalX = 0, totalY = 0, count = 0;
            region.lines.forEach(line => { line.forEach(pt => { totalX += pt[0]; totalY += pt[1]; count++; }); });
            if (count === 0) return;
            const cx = totalX / count; const cy = totalY / count;
            const rad = region.angle * Math.PI / 180; const cos = Math.cos(rad); const sin = Math.sin(rad);
            const newLines = region.lines.map(line => {
                return line.map(pt => {
                    const dx = pt[0] - cx; const dy = pt[1] - cy;
                    return [ dx * cos - dy * sin + cx, dx * sin + dy * cos + cy ];
                });
            });
            region.lines = newLines;
        }
        // --- ç»‘å®šäº‹ä»¶ (åœ¨åº•éƒ¨ JS åŒºåŸŸ) ---
        btnResetSidebar.addEventListener('click', resetTextareaContent);

        // --- æ–°å¢é‡ç½®å‡½æ•° ---
        function resetTextareaContent() {
            if (activeRegionIndex !== -1 && regions[activeRegionIndex]) {
                const r = regions[activeRegionIndex];
                
                // --- 1. è¿˜åŸè¯‘æ–‡é€»è¾‘ ---
                const transSnapshot = r.transSnapshot || "";
                document.getElementById('transEditArea').value = transSnapshot.replace(/ã€BRã€‘/g, '\n');
                r.translation = transSnapshot;
                
                // --- 2. è¿˜åŸåŸæ–‡é€»è¾‘ ---
                const origSnapshot = r.origSnapshot || [];
                document.getElementById('origEditArea').value = origSnapshot.join('\n');
                r.texts = [...origSnapshot];

                // --- 3. è§†è§‰åé¦ˆä¸é‡ç»˜ ---
                draw();
                
                // ä¸¤ä¸ªæ¡†çš„è¾¹æ¡†å˜çº¢é—ªçƒä¸€ä¸‹ï¼Œæç¤ºå·²é‡ç½®
                const tArea = document.getElementById('transEditArea');
                const oArea = document.getElementById('origEditArea');
                tArea.style.borderColor = '#ef4444';
                oArea.style.borderColor = '#ef4444';
                setTimeout(() => {
                    tArea.style.borderColor = '#4b5563';
                    oArea.style.borderColor = '#4b5563';
                }, 500);
            }
        }



        // ç‚¹å‡»é¢„è§ˆå—æ‰“å¼€å–è‰²å™¨
        document.getElementById('btnBlurColor').addEventListener('click', () => {
            colorPickTargetIndex = activeRegionIndex;
            let currentColor = (colorPickTargetIndex !== -1 && regions[colorPickTargetIndex]) ? 
                (regions[colorPickTargetIndex].blurColor || "#000000") : "#000000";
            nativeBlurPicker.value = colorToHex(currentColor);
            nativeBlurPicker.click();
        });


        // è¡¥å……ï¼šå‘å…‰å¼€å…³å’Œå¤§å°çš„å³æ—¶ç›‘å¬
        // --- ä¿®æ”¹åçš„å‘å…‰æ§åˆ¶ç›‘å¬ ---
        document.getElementById('blurEnable').addEventListener('change', (e) => {
            if (activeRegionIndex !== -1 && regions[activeRegionIndex]) {
                regions[activeRegionIndex].blurEnable = e.target.checked;
                draw();
            }
        });

        // è„šæœ¬æœ«å°¾çš„ç›‘å¬å™¨
        document.getElementById('blurSizeInput').addEventListener('input', (e) => {
            if (activeRegionIndex !== -1 && regions[activeRegionIndex]) {
                // å­˜å‚¨ä¸ºæ¯”ä¾‹
                regions[activeRegionIndex].blurSizeRatio = parseFloat(e.target.value) || 0;
                draw();
            }
        });


        // è¯‘æ–‡å³æ—¶é‡ç»˜ï¼šå¤„ç†æ¢è¡Œæ ‡ç­¾
        document.getElementById('transEditArea').addEventListener('input', (e) => {
            if (activeRegionIndex !== -1 && regions[activeRegionIndex]) {
                regions[activeRegionIndex].translation = e.target.value.replace(/\n/g, 'ã€BRã€‘');
                draw();
            }
        });

        // åŸæ–‡å³æ—¶é‡ç»˜ï¼šå¤„ç†æ•°ç»„æ‹†åˆ†
        document.getElementById('origEditArea').addEventListener('input', (e) => {
            if (activeRegionIndex !== -1 && regions[activeRegionIndex]) {
                regions[activeRegionIndex].texts = e.target.value.split('\n');
                draw();
            }
        });

        resetSidebar();
    </script>
</body>
</html>